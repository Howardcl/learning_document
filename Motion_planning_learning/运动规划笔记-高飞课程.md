# 1.概述和课程介绍

（1） 研究内容：移动机器人的运动规划。这门课的主讲老师，就是文章（TGK-planner）的通讯作者。课程内容与文章内容有很高的相关性。

![image-20210913085423461](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085423461.png)

（2） 学习路线

![image-20210913085409570](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085409570.png)

前端路径发现（搜索）：在一个相对低维的通常是离散的状态空间中，让机器人搜索一个初始的（解的质量不是特别好的）path,没有高维的信息。

后端的轨迹优化（生成）：在高维的连续空间中执行的（寻找一个可执行的轨迹），要用到很多的优化技巧。

**前端：Path finding**

## **1.1基于搜索的Path finding**

A) 图的基本概念：机器人为了在环境中进行导航，会用到很多种类型的地图。

配置空间：维度等于机器人的自由度，可以理解为一个点可以表示一个机器人的位姿。例如小车4自由度(x,y,z,θ)。在配置空间中，机器人表示为点。

在3维空间中，要做碰撞检测，就很麻烦。所以在配置空间中做规划，要对障碍物按照机器人的尺寸做膨胀。

**基于图搜索的算法框架：**

![image-20211014152338760](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014152338760.png)

关键问题：

如果一个结点被弹出容器，就不再会被加入到容器中

BFS使用的容器是队列，DFS使用的是栈。在边的权重都为1的情况下，BFS能保证路径最短，所以搜索算法是基于BFS的。



## 1.2 Dijkstra and A*算法

与BFS相比，**Dijkstra**从容器中弹出的规则不同。Dijkstra弹出的是从起点到某点的走过的距离最短的点。也就是说，容器不再使用队列，而是**优先队列**，弹出的总是走过路径最短的点。**(优先级队列会自动排序，把g(n)值最小的节点放在最下面)**

优点：完备的，能保证最优解;

缺点：没有启发，就是暴力搜，没有关于终点的信息。

**A***
相比于Dijkstra，A*的容器对元素的排序依赖的是（走过的路径的距离+启发距离）。某节点启发距离是指预测的从该节点到终点的距离。

当启发距离小于真实距离的时候，A*能找到最优解。

工程改进：
1）使用Diagonal Heuristic：用norm做的启发函数都过分的低估了实际距离，使得搜索的区域很大
2）Tie Breaker：可能存在很多条路都是最优解。打破路径的对称性，使得搜索更偏向于一条路

## 1.3 JPS

Jump Point Search(跳点算法，实际上是A*的改良版本)

**Look Ahead Rule + Jumping Rule**
相比于A*，visit一个结点后，**使用Jumping Rule来扩展该节点**，把从该节点jumping的后继结点加入到容器中

对于复杂环境，JPS总的来说要比A*好
**JPS只能用于uniform grid使用**



**2) 基于采样的Path finding**

A) Probabilistic Road Map概率路线图:经典的随机采样的路径规划方法

B) Rapidly-exploring Random Tree随机扩展快速采样的随机树算法（RRT）

C) Optimal Sampling-based Methods  具有渐进最优性的改良版本,称为RRT*



**3) Kinodynamic Path finding(满足动力学要求的轨迹规划，开始考虑动力学模型)**

A) State-State Boundary Value Optimal Control Problem满足两点边界值的最优控制问题

B) State Lattice Search**状态图的搜索（其实是高维的Dijkstra或A*）**

C) Kinodynamic RRT 引入动力学的RRT

![image-20210913085519021](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085519021.png)

**D) Hybrid A* 混合A*算法**

**后端：Trajectory Generation**

1) Minimum Snap 轨迹生成,再交给移动机器人执行

![image-20210913085553057](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085553057.png)

**2）Soft and Hard Constrained Trajectory Optimization**

A) 软约束轨迹优化

B) 硬约束轨迹优化

## 1.4 DWA算法

一、DWA原理
仔细想想，机器人的运动状态，包括其不停变换的位置及运动方向，实际上是由其当前的运动速度及角速度（转向速度）决定的。那么，动态窗口法核心的动态窗口，其实就是将机器人当前状态（即当前速度，航向角）及机器人运动模型（机器人所能达到的最大速度，最大角速度，加速度，旋转加速度）计算出当前机器人的最大最小速度及角速度，以此作为一个限定范围，这个范围就是窗口。在此范围中计算每个速度及角速度下所能到达到的位置，在对每个位置进行测评（测评内容包括据障碍物的距离，朝向终点的角度等），由此选出当前的最佳位置，然后再由这个最佳位置继续重复以上过程建立新的窗口，这样窗口就动起来了，即所谓的动态窗口。

### 1.机器人的运动模型

![img](https://img-blog.csdn.net/20150410185658311)

![img](https://img-blog.csdn.net/20150410192038912)

![img](https://img-blog.csdn.net/20150410192044388)

### 2.速度采样  

机器人的轨迹运动模型有了，根据速度就可以推算出轨迹。因此只需采样很多速度，推算轨迹，然后评价这些轨迹好不好就行了。 

（一）移动机器人受自身最大速度最小速度的限制: ![[公式]](https://www.zhihu.com/equation?tex=V_%7Bs%7D) 为机器人能够到达的所有矢量速度的集合；机器人受到最大最小线速度和角速度影响。

![preview](https://pic2.zhimg.com/v2-8a5c79fcbf6253c1656edbb2c43b76f9_r.jpg) 

（二） 移动机器人受电机性能的影响:由于电机力矩有限,存在最大的加減速限制,因此移动机器人軌迹前向模拟的周期sim_period内,存在一个动态窗口,在该窗口内的速度是机器人能够实际达到的速度:   ![preview](https://pic2.zhimg.com/v2-23c849941c6fd3fdeb3d506cb096ea65_r.jpg)

（三) 基于移动机器人安全的考虑:为了能够在碰到障碍物前停下来, 因此在最大减速度条件下, 速度有一个范围: 其中dist(v,w)为（v,w）对应的轨迹上里障碍物最近的距离。

![preview](https://pic4.zhimg.com/v2-85d8de192ea4b217660e4a8eceef6857_r.jpg)

在上述三条约束条件的限制下，速度空间（v,w）会有一定的范围，另外会随着电机的线加速度、角加速度进行变换，速度空间会动态变化，我们将其称为**动态窗口**。在满足约束条件的情况下，进行采样（v,w），可以得到相应的轨迹：

![preview](https://pic4.zhimg.com/v2-ad22909389267f32cb092a9b6b548a07_r.jpg)

### 3.算法程序分析

（1）初始化：     

​	在move_base节点中，通过类加载模块载入了BaseLocalPlanner（局部路径规划）的子类DWAPlannerROS的实例tc_，并调用其初始化函数，获取了一些初始状态信息比如机器人当前位置等，并创建了真正实现DWA算法的DWAPlanner类的实例dp_，最后设置了动态参数配置服务。dp_的构造函数做了一系列参数获取的操作，最重要的是将几种cost计算方法的实例加入一个名为critics的vector容器里。 

（2）采样速度样本：     

​	当move_base调用tc_的computeVelocityCommands方法后，tc_会调用dwaComputeVelocityCommands方法，并在其中调用dp_的findBestPath方法。findBestPath方法里调用SimpleTrajectoryGenerator类的实例generator_的initialise函数，这个函数就是主要负责速度采样的。  

每个维度速度需要采样的养本数存放在vsamples_这个结构体内，vsamples_[0]是x方向样本数，vsamples_[1]是y方向样本数，vsamples_[2]是z方向样本数。首先计算各个方向的最大速度和最小速度，DWA算法只在第一步进行采样，所以最大速度为:  Max_vel=min(max_vel,vel+acc_lim*sim_period)  最小速度为:  Min_vel=max(min_vel,vel-acc_lim*sim_period)  其中max_vel，min_vel为人为设定的最大和最小速度，vel是当前速度，acc_lim是人为设定的最大加速度，sim_period是第一步的模拟时间，由人为设定的局部路径规划频率决定，默认为0.05。

  当计算出各个维度的最大最小速度后，就创建三个VelocityIterator类的对象，并传入最大最小速度和样本数目，此对象的构造函数会生成同样数目的速度样本并放入samples_这个容器内。_

具体做法是先计算步长step_size：  step_size=(max-min)/(nums_samples-1)  max为最大速度，min为最小速度，nums_samples为样本数目。从最小速度每次多累加一次step_size即为一个速度样本，直到达到最大速度。将每个维度的速度样本取得后，再全部循环每个样本组里选择一个组合放入结构体vel_sample，最后将这些vel_sample放入sample_params_的容器里。至此，速度采样就完成了。  

（3）样本评分 ：

​     速度采样完成后，逐一循环对样本空间内的样本进行评分。对每一组速度调用scoreTrajectory函数计算其评分，而scoreTrajectory函数则对这一组速度调用所有critics容器里的costfunction计算每个cost从而累加算出总的cost。在计算过程中，一旦累加的cost大于当前最小的cost则抛弃这组速度。  

之前说到的几种cost成本函数为下列所示：  

ObstacleCostFunction  这个成本函数基于感知障碍物来评估轨迹。它或者由于轨迹通过障碍物而返回负值，或者0。  

MapGridCostFunction  这个成本函数类基于轨迹离全局路径或者接近目标点有多近来评估轨迹。这个尝试利用距离预计算地图有相同距离的路径或者目标点的所有的规划，来优惠计算速度。  在 dwa_local_planner中，代价函数因为不同的目的，被多次实例化。保持轨迹接近于路径，使机器人朝局部目标前进，并且使机器人的前段点指向局部目标。代价函数是一个启发，可以带来坏的结果或者不合适的参数的失败。 

 OscillationCostFunction  震荡发生在X,Y,theta维度上，正/负值被连续的选择。为了阻止震荡，当机器人在任何方向移动时，与下一个循环相反的方向被标记为无效，直到机器人已经从所设置标记的位置移动而并且超过一定的距离。这个成本函数类帮助减少某些震荡，虽然这可以有效的阻止这些震荡，如果使用不合适的参数，但是有可能阻止良好的解。  

PreferForwardCostFunction  考虑到好的激光扫描范围只在机器人的前面，这个成本函数类被设计在像PR2一样的机器人上。成本函数更喜欢正面向前运动，惩罚背面运用及扫射动作。在其他机器人上或者其他领域，这可能是非常不可取的行为。  

**总共七个cost function, 总结一下分别的作用就是：**
1， 保证不会前后移动频繁切换
2， 保证没有大角度转动
3，保证没有碰撞
4，保证与局部路径终点距离短
5，保证与局部路径终点朝向一致
6，保证与局部路径横向偏差小
7，保证与局部路径朝向一致

在扫地机上用到的七类代价：

**七类代价：**

1.到目标点的距离代价

2.轨迹点向前偏移后的位置到障碍物的距离的代价

3.轨迹终点到障碍物的距离的代价（越近代价越高）

4.防抖动代价

5.轨迹点到局部路径距离的代价（距离目标点越远，代价越大），使用这个估价函数要求被对比的轨迹的长度均相等

6.优先原地转的代价

7.旋转防抖动代价



（4）发布plan     

​	通过上述几种评分机制，选取最优的一组速度样本，传递给move_base，并发布相应的local plan。move_base如果收到了可用的速度则发布给底盘，否则发布0速度，且如果寻找最优速度的时间超过了限制就会执行障碍物清理模式，state_会变为CLEARING。  

## 1.5 TEB算法

### 1.Teb 方法概述

也是一种局部规划算法。

TEB 全称 Time Elastic Band（时间弹性带）Local Planner，该方法针对全局路径规划器生成的初始全局轨迹进行后续修正，从而优化机器人的运动轨迹，属于局部路径规划。在轨迹优化过程中，该算法拥有多种优化目标，包括但不限于：整体路径长度、轨迹运行时间、与障碍物的距离、通过中间路径点以及机器人动力学、运动学以及几何约束的符合性。

TEB 被表述为一个多目标优化问题，大多数目标都是局部的，只与一小部分参数相关，因为它们只依赖于几个连续的机器人状态。这种局部结构产生了一个稀疏的系统矩阵，使得它可以使用快速高效的优化技术，例如使用开源框架 g2o 来解决 TEB 问题。

**通俗的解释就是 TEB 生成的局部轨迹由一系列带有时间信息的离散位姿(pose)组成，g2o 算法优化的目标即这些离散的位姿，使最终由这些离散位姿组成的轨迹能达到时间最短、距离最短、远离障碍物等目标，同时限制速度与加速度使轨迹满足机器人的运动学**。

需要指出的是 g2o 优化的结果并非一定满足约束，即实际都是软约束条件，若参数设置不合理或环境过于苛刻，teb 都有可能失败，规划出非常奇怪的轨迹。所以在 teb 算法中包含有冲突检测的部分，在生成轨迹之后逐点判断轨迹上的点是否与障碍物冲突，此过程考虑机器人的实际轮廓。

### 2.Teb 基本原理

#### Eletic Band

连接起始、目标点，并让这个路径可以变形，变形的条件就是将所有约束当做橡皮筋的外力。

![img](https://static.leiphone.com/uploads/new/article/740_740/201612/585c732f9ccc9.gif)

#### Time Eletic Band

起始点、目标点状态由用户的全局规划器指定，中间插入 N 个控制橡皮筋形状的控制点（机器人姿态）。为了显示轨迹的运动学信息，我们在点与点之间定义运动时间 Time，即：

```
Time + Elastic Band = Timed Elatics Band
```



- 1）写一个全局规划器，让电动车能在任意两个停车点之间找到开车路线；
- 2）写一个局部规划器，控制电动车跟随全局轨迹，并实现避障等功能。

So easy!

由于每个停车点相对固定、校园环境也比较简单，所以全局规划器并不复杂，将校园地图做成网格（或拓扑图），跑一个A*就可以了。当然，毕竟我是机动学院的，所以我做的这种车也只能走机动车道，为了防止它跑出机动车道，可以加一个costmap。不多说。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c72306673a.png?imageMogr2/quality/90)



costmap示意图，让距离不可行区域（如非机动车道）较近的路径耗费更高即可

写完全局规划器，就只剩下局部规划器了。

这个局部规划器也简单，看了文献，大概有个叫做Timed-Elastic-Band的多目标优化方法，只要写出需要满足的优化目标函数即可：

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c725953700.png?imageMogr2/quality/90)

算了，差不多这样就可以了，出于严谨的科学态度，我用stage搭了一个仿真平台，测试这个算法。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c726de5dba.gif)

哎呦，不错哟！

那就直接上真车吧。但毕竟「××」分时租赁不肯赞助我，我没办法用他们的车做实验，我只能把视线投向了实验室的移动小车。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c7291108d1.png?imageMogr2/quality/90)

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c72b417930.gif)

算了，我还是去当电影剪辑师好了。

===============

不好意思，上面都是临时工写的。为了不剧透，临时工剪辑的视频也放在最后。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c72d5cd623.gif)

由于之前一直宣扬「path planning 跟 motion planning 在数学上是一个问题」，于是被拉入坑，让我去做这个自动驾驶车的东西。

当然，一开始让我去做这个路径规划，其实我的拒绝的。

但后来一想，正好能在低维情况下试试那些基于优化的路径规划算法，然后顺便再发篇论文，也不错。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c72ed7fc5a.gif)

全局规划器跟上面临时工说得差不多，就是**costmap + graph search**。costmap就是根据地图的可行区域，再通过耗费函数计算出来的一个图。即，

cost function + map = costmap

**重点是局部规划器**。

由于，局部规划器所需满足的约束条件比较多，就可以通过设计一堆由路径决定的优化目标函数，利用优化算法对它求解进行了。

对于二维路径的描述，有一个有趣的方法，叫做**Elatic Band**（橡皮筋）。

简而言之，就是连接起始、目标点，并让这个路径可以变形，变形的条件就是将所有约束当做橡皮筋的外力。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c732f9ccc9.gif)

先定义一下我们的橡皮筋：

起始点、目标点状态由用户/全局规划器指定，中间插入N个控制橡皮筋形状的控制点（机器人姿态），当然，为了显示轨迹的运动学信息，我们在点与点之间定义运动时间Time。于是，这个方法就叫做**Timed-Elastic-Band**。即

time + elastic band = timed elatics band

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c738529a7d.png?imageMogr2/quality/90)

之后就需要定义「内外力」的数学表达形式，即目标函数。（以下均为中学知识）

**1) 要跟踪全局轨迹+要避开障碍物**：

这两个其实算是一类问题，都是在橡皮筋上找到距离某一点（全局路径点/障碍物）最近的状态，计算两者之间距离，之后定义一个基于距离的势场就好了。

当然，上面两种目标函数随距离变化方向正好相反，一个随着距离增大而增大（跟踪），一个随着距离增大而减小（障碍物）。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c73a22f5ed.png?imageMogr2/quality/90)

**2) 加速度/速度限制**

这个其实就是一个不等式约束。

我们的橡皮筋只定义了姿态（x,y,θ）与两两状态直接的时间，所以就直接用差分近似计算好了。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c73bb23ec7.png?imageMogr2/quality/90)

**3) 运动学限制**

这个比较重要，毕竟我们一般都不希望自己的车漂移起来。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c73d0e7023.gif)

所以，我们的控制量只有车速（油门）与转角（方向盘）。

我们假设两个状态点之间转角相同，（如果发生了转向，中间加状态点就好了）。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c73e70abf6.png?imageMogr2/quality/90)

简单的向量叉乘求夹角即可

当然，由于汽车的结构限制，汽车会有一个最小转弯半径。（毕竟汽车不能原地转弯）

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c73ffe760e.gif)

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c74244c02c.png?imageMogr2/quality/90)

**4) 当然，如果有其他约束也可以扔进去**

目标函数都定好之后，就需要进行求解了。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c744781d58.png?imageMogr2/quality/90)

这么复杂的多目标优化问题，一看就不想做

好吧，这步虽然看似复杂，但是了解SLAM或者SFM的同学应该能很快反应过来，这就是一个**bundle adjustment问题**。

简而言之，虽然待优化的橡皮筋有不少状态点与时间段，目标函数也好像很多。但是，**每个目标函数只与橡皮筋中的某几个状态有关，而非整条橡皮筋**。认识到这是一个稀疏优化（Sparse Optimization）问题就比较容易了。

将它描述成图，然后用图优化。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c7472bdd94.gif)

如图，这个图的节点vertexs是橡皮筋的状态（机器人姿态+时间）；图的边edges是我们自己定义的优化目标函数。

求解的框架，自然是可以去使用g2o（A General Framework for Graph Optimization）了。当然，节点和边的类型需要我们自己利用g2o中的模板定义。

![听说现在自动驾驶很火，所以我也做了一个](https://static.leiphone.com/uploads/new/article/740_740/201612/585c748b38063.gif)

g2o 框架

g20 是通用图优化（General Graph Optimization）库，g2o 的核里带有各种各样的求解器，而它的顶点、边的类型则多种多样，通过自定义顶点和边（TEB 把 `configuration` 和 ΔTiΔTi 当作顶点，约束函数当作边，代码内部自定义了这 2 个类型），事实上只要一个优化问题能够表达成图，那么就可以用 g2o 去求解它，g2o 代码框架如下：

![img](https://images2015.cnblogs.com/blog/606958/201603/606958-20160321233900042-681579456.png)



## **1.6常用地图结构**

1.**占用栅格地图**

**![image-20210921104259435](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104259435.png)**

- 最稠密--每隔一个距离就要进行切分（当每个格子切的比较小也就是分辨率比较大的时候，内存非常大）

- 结构化

- **坐标索引查询，O(1)**

  

**2、Octo-map 八叉树地图**

环境中没有障碍物的地方，就用大的方块表示，当大方块里面有小部分有障碍物，就递归地切分下去，直到包含了障碍物为止。

- 稀疏的

- 结构化

- 非直接索引查询

  ![image-20210921104440591](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104440591.png)

**3、Voxel hashing 体素哈希**

通过二重哈希表来存储障碍物边界的每个voxel（单元栅格）

![image-20210921104552046](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104552046.png)

**4、Point cloud map 点云地图**

- 无序

- 无索引查询

  ![image-20210921104626501](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104626501.png)

**5、TSDF map (Truncated Signed Distance Functions) 截断的有符号距离函数**

距离值：曲面外部为正值，内部为负值，并且可以以距离的大小来进行截断，比如正负两米内的点保留。

![image-20210921104758485](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104758485.png)

**6、ESDF map（Euclidean Signed Distance Functions）欧式有符号距离函数**

TSDF不截断的话，就是ESDF

当进行轨迹规划时，需要知道机器人距离障碍物的梯度，所以不需要进行截断。

![image-20210921105253062](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105253062.png)

**7、其他**

[Free-space Roadmap](https://link.zhihu.com/?target=https%3A//github.com/HKUST-Aerial-Robotics/Teach-Repeat-Replan)：随机采样的概率路线图，用**凸多面体**来表示路径点，再连接起来

![image-20210921105343506](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105343506.png)

[Voronoi Diagram Map](https://link.zhihu.com/?target=https%3A//github.com/ethz-asl/mav_voxblox_planning)：利用ESDF提取地图的骨架--拓扑结构，稀疏

![image-20210921105354578](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105354578.png)

**8.Costmap(代价地图)（上）**
Costmap是机器人收集传感器信息建立和更新的二维或三维地图，**可以从下图简要了解。**


![这里写图片描述](https://img-blog.csdn.net/20170504191642538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHF5Z2FtZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


上图中，红色部分代表costmap中的障碍物，**蓝色部分表示通过机器人内切圆半径膨胀出的障碍**（注意是机器人内切圆形状），红色多边形是**footprint**（**脚印**）(**机器人轮廓的垂直投影**)。

**机器人避障的规则：**为了避免碰撞，footprint不应该和红色部分有交叉，机器人中心不应该与蓝色部分有交叉。

**代价地图结构形式：**
ROS的代价地图（costmap）采用网格（grid）形式，每个网格的值（cell cost）从0~255。分成三种状态：**被占用（有障碍**）、**自由区域（无障碍）、未知区域；**


**具体状态和值对应有下图：**


![这里写图片描述](https://img-blog.csdn.net/20170504190335219?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHF5Z2FtZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


上图可分为五部分，**其中红色多边形区域为机器人的轮廓：**
（1） **Lethal**（致命的）:机器人的中心与该网格的中心重合，此时机器人必然与障碍物冲突。
（2） **Inscribed**（内切）：网格的外切圆与机器人的轮廓内切，此时机器人也必然与障碍物冲突。
（3）**Possibly circumscribed**（外切）：网格的外切圆与机器人的轮廓外切，此时机器人相当于靠在障碍物附近，所以不一定冲突。
（4） **Freespace**（自由空间）：没有障碍物的空间。
（5） **Unknown**（未知）：未知的空间。

 

**Code处理逻辑：**
ROS中costmap_2d这个包提供了一个可以配置的结构维护costmap,其中Costmap通过costmap_2d::Costmap2DROS对象利用传感器数据和静态地图中的信息来存储和更新现实世界中障碍物的信息。costmap_2d::Costmap2DROS为用户提供了纯粹的2维索引，这样可以只通过columns查询障碍物。举个例子来说，一个桌子和一双鞋子在xy平面的相同位置，**有不同的Z坐标，在costm_2d::Costmap2DROS目标对应的的costmap中，具有相同的cost值。这旨在帮助规划平面空间**。


Costmap由多层组成，例如在costmap_2d包中，1.**StaticLayer（静态地图层）是第一层**， **2.ObstacleLayer（障碍物层）是第二层，3.InflationLayer（膨胀层）是第三层。**  **这三层组合成了master map（最终的costmap），供给路线规划模块使用。**

**最终输出mast map给path planing 模块使用。**
Costmap主接口是costmap_2d::Costmap2DROS，它维持了Costmap在ROS中大多数的相关的功能。它用所包含的costmap_2d::LayeredCostmap类来跟踪每一个层。每层使用pluginlib（ROS插件机制）来实例化并添加到LayeredCostmap类的对象中。各个层可以被独立的编译，且允许使用C++接口对costmap做出任意的改变。


**Costmap ROS接口：**
ROS对costmap进行了复杂的封装，提供给用户的主要接口是Costmap2DROS,而真正的地图信息是储存在各个Layer中。下图可以简要说明Costmap的各种接口的关系：


![这里写图片描述](https://img-blog.csdn.net/20170504190430375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHF5Z2FtZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


Costmap的ObstacleLayer和StaticLayer都继承于CostmapLayer和Costmap2D,因为它们都有自己的地图，Costmap2D为它们提供存储地图的父类，CostmapLayer为它们提供一些对地图的操作方法。而inflationLayer因为没有维护真正的地图所以只和CostmapLayer一起继承于Layer，Layer提供了操作master map的途径。
LayerdCostmap为Costmap2DROS（用户接口）提供了加载地图层的插件机制，每个插件（即地图层）都是Layer类型的。


**Costmap初始化流程：**
在navigation的主节点move_base中，建立了两个costmap。其中planner_costmap_ros_是用于全局导航的地图，controller_costmap_ros_是用于局部导航用的地图。下图为costmap的初始化流程。


![这里写图片描述](https://img-blog.csdn.net/20170504190526248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHF5Z2FtZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


（1）Costmap初始化首先获得全局坐标系和机器人坐标系的转换（**世界坐标系和机器人坐标系相对变化关系**）
（2）加载各个Layer，例如**StaticLayer**，**ObstacleLayer**，**InflationLayer**。
（3）**设置机器人的轮廓**
（4）实例化了一个Costmap2DPublisher来发布可视化数据。
（5）通过一个movementCB**函数不断检测机器人是否在运动**
（6）开启动态参数配置服务，**服务启动了更新map的线程。**


**Costmap更新**
Costmap的更新在mapUpdateLoop线程中实现，**此线程分为两个阶段：**
（阶段一）UpdateBounds：这个阶段会更新每个Layer的更新区域，这样在每个运行周期内减少了数据拷贝的操作时间。StaticLayer的Static map只在第一次做更新，Bounds 范围是整张Map的大小，而且在UpdateBounds过程中没有对Static Map层的数据做过任何的更新。ObstacleLayer在这个阶段主要的操作是更新ObstaclesMap层的数据，然后更新Bounds。InflationLayer则保持上一次的Bounds。


（阶段二）UpdateCosts：这个阶段将各层数据逐一拷贝到Master Map，可以通过下图观察Master Map的生成流程。（图来源于**David Lu的《Layered Costmaps for Context-Sensitive Navigation》）**


![这里写图片描述](https://img-blog.csdn.net/20170504190719658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHF5Z2FtZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


在（a）中，初始有三个Layer和Master costmap,Static Layer和Obstacles Layer维护它们自己的栅格地图，而inflation Layer并没有。为了更新costmap,算法首先在各层上调用自己的UpdateBounds方法（b）。为了决定新的bounds,Obstacles Layer利用新的传感器数据更新它的costmap。**然后每个层轮流用UpdateCosts方法更新Master costmap的某个区域,从Static Layer开始（c），然后是Obstacles Layer(d)，最后是inflation Layer(e)。**

==**Motion planning当前的研究难点：**==

kinodynamic path searching。纯geometric path search的planning前端已经是几年前的事情了，要让无人机飞行动态性能好（速度快，运动smooth，节省能量），现在普遍需要的是on the flight的onboard kinodynamic path finding，之后再接上后端的轨迹优化。kinodynamic path searching解空间维度高，问题复杂度大，引申出来的问题包括：如何快速求解two point bounda value problem, 如何针对你的系统设计高效的heuristic，如何保证每次replan前后的motion consistency。最简单的测试指标，复杂环境里，你能让无人机飞多快？环境越复杂，飞的越快，就越NB。

**---转自 高飞**

![image-20210921093624071](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921093624071.png)

栅格地图：对环境进行方格化、离散化的栅格地图，维护一个栅格地图需要很大的内存空间。

欧氏距离场：欧氏距离场首先需要一个栅格地图，此外欧氏距离场记录了栅格地图里每一个点到最近的障碍物点的距离和方向，所以可以进行梯度计算，因此非常适合于无人机的局部避障，因为可以判断每个障碍物点对。

八叉树地图：改善了栅格地图占内存很大的缺点。

**==飞行走廊：因为障碍物是不规则的，所以用凸多面体把环境里的free-space抠出来，反正障碍物不会在飞行走廊里，接下来飞行器只需要在飞行走廊里运动就可以==**

用飞行走廊这样一种几何空间的约束去表述环境中的可行空间之后，我们就可以去求解一个，把椭球状的无人机叠加一个model，约束在飞行走廊里的一个后端优化问题。

# 2.基于搜索的路径规划

## 2.1 机器人规划的配置空间：

Configuration Space:对机器人上所有点的位置的描述。在配置空间中做规划：将工作空间中的planning变成配置空间中的planning。

在配置空间中要注意对障碍物的处理：C-obstacle；对障碍物和机器人的体积做膨胀。 处理过后，运动规划就是在C-free空间中找到一条从开始点到目标点的路径。

![image-20210913085606665](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085606665.png)

![image-20210913085611242](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085611242.png)

## 2.2 图搜索算法的总体框架

A) 总是要维护一个容器：这个容器装载着全部将来要去访问的节点。

B) 这个容器一开始是空的，最先放入的是起始点。

C) 最后进入一个循环。各种搜索算法其实都可以归结在这个循环框架里 

循环分为三步：

1）弹出一个节点（根据一项指标、一种目的）Remove

2）扩展这个节点所有的邻居Expansion

3）对于所有扩展出来邻居节点，再重新装入容器中。Push

循环持续到：容器中没有任何节点可以被弹出为止。

![image-20210913085624694](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085624694.png)

图的遍历：

![image-20210913085643266](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085643266.png)

DFS弹出容器中最深的节点，在每次扩展时把每个可能的分支走到底。

BFS弹出容器中最浅的节点，所以BFS是分层遍历的。

贪心算法：每次都选择局部最优。

用BFS搜索的前提是图中每条边的权重是相同的，比如都是1.

**Dijkstra算法**：弹出的节点n需具有最小的cost: g(n):从起点到n节点的代价总和最小。如果所有边的权重都是1的话，Dijkstra算法等同于BFS。

![image-20210913085703625](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085703625.png)

**A\*算法：Dijkstra算法Cost g(n) + 启发式h(n)**

![image-20210913085710286](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085710286.png)

![image-20210913085737357](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085737357.png)

![image-20210913085743251](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085743251.png)

**==几种方式的区别：贪婪、加权A$*$ 、A$*$、Dijkstra==**

![image-20210923194256819](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923194256819.png)

**Jump Point Search跳点搜索：打破对称性**

![image-20210913085754127](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085754127.png)

Look Ahead Rule: (Straight pruning rule)如果一个节点可以通过x的父亲到达（在cost小于等于的前提下），那就没有必要通过x到达。(跳点，打破对称性）

![image-20210913085805964](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085805964.png)

上方左图红色箭头代表父节点的来源。（分为直线来源和对角线来源）

当出现障碍物邻居的时候，就会出现Forced Neighbors.

优先考虑水平和垂直方向的跳跃。

 

![image-20210913085831401](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085831401.png)

优先考虑水平和垂直方向的跳跃。（地图边界等同于障碍物处理，在右三图中，水平和垂直方向的跳跃都会失败，因为都会碰到障碍物）于是进行对角线跳跃，到y节点。y节点是一个关键节点。

将Forced neighbors(expanded)加入优先级队列中(push),将父节点x弹出(Remove).

![image-20210913085853615](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085853615.png)

不会有折线跳跃，每一次的跳跃一定是直线的。

![image-20210913085901597](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085901597.png)

A*的代码与JPS的代码几乎一致，唯一的区别在于怎么去找n节点未扩展的邻居。

A*的邻居找的是几何上能达到的邻居（除去障碍物的邻居节点）。但JPS找的邻居是根据跳点规则和look Ahead规则找到的跳点邻居。

A*在扩展几何上紧密连接的邻居，而JPS在地图上空阔区域进行大范围的跳跃。 

![image-20210913085917844](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085917844.png)

![image-20210913085932408](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085932408.png)

**在大多数情况下，尤其是复杂环境中，JPS比A*更快**。因为它减少了优先级队列中扩展的节点数量，在队列中对节点进行的操作次数也会变少，从而节省计算量；但是它增加了环境中碰撞查询（collision query）的次数,积少成多也会是一笔计算开销。

![image-20210913085942012](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085942012.png)

JPS的限制：只适用于规则的栅格地图。

![image-20210913085952057](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085952057.png)

**==基于搜索的路径规划方法建立在地图的基础之上，通过对图的搜索，规划出从点A到点B的最优路径。==**

**基于采样的路径规划**：不需要遍历从点A到点B的所有网格，而是**通过在空间中随机洒点，通过一些线段把这些点连接起来**的方式，构建一颗树（图），来表示空间。尤其适用于复杂空间，适用于三维或更高维的情况。



# 3.基于采样的路径规划

采样：在空间中撒一些点，然后用线段把这些点连起来，形成图。 然后这个图代表了简化的地图。从而在这个图结构上找从start点到Goal点的方式。

优点：更加高效，尤其适用于复杂空间及三维或更高维的环境。

Completeness in planning 规划的完备性。

比如A*算法就具备这样的完备性

**概率完备性：如果有这样一条路径存在，那么通过采样的方式，一定能把这条路径找出来。**

![image-20210923193040575](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923193040575.png)



![image-20210921111652729](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921111652729.png)

## 3.1 概率路图PRM

![image-20210921111801438](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921111801438.png)

PRM是一种图结构，分为两个阶段：学习阶段和查询阶段。

**学习阶段**：我们希望对冗长的地图做一个简化，如何简化：就是通过对图的学习，从而找出一个简化地图。

具体方式：

1.在环境中均匀地撒一些点（也有偏置式、启发式的撒点）；

2.删除在障碍物区域内的点；

3.（可以根据一定的规则）连接近邻的几个点；

4.删除和环境碰撞的路径段（或过长的线段）。

**查询阶段：就用A*或Dijkstra算法**

![image-20210923193955644](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923193955644.png)

优点：概率完备、简化了图之后，相对于A*或Dijkstra算法而言是高效的。

缺点：

1.现在用直线来连接2个点，但是对于机器人而言，有些轨迹是不适合运动的，不是最优效率。

2.不够高效，没有把找一条路径放在心上。

不够高效的第一个原因：

1.检测点或线段是否在障碍物中，是很耗时的。

解决办法：先不管线段是否碰撞了障碍物，lazy collsion-checking.

![image-20210923200752190](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923200752190.png)

![image-20210923202057845](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923202057845.png)

找到一条路径之后，再对这条路径进行Collsion-checking，然后删掉碰撞的点和边，然后重新开始寻找路径。



## 3.2 快速搜索随机树Rapidly-exploring Random Tree

相比于PRM更有针对性，能够快速地在空间中规划一条路径，在高维空间里更快。

树是增量式构建的，不需要区分learning phase和query phase,它的目标就是构造一条路径。也不需要利用Dijkstra和A*算法，只要终点被加入到路径中，就进行反方向查询，就可以找到可行路径。

![image-20210924104628078](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924104628078.png)

![image-20210924105310925](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924105310925.png)

RRT优点：1.目标是找到一条从起点到终点的路径；2.相对PRM更以目标为导向。

缺点：1.并不是最优路径；2.相对来说，也没有那么高效；

**改进方法：提高效率**

Kd-tree：把一些点用做空间的划分，这些点并不是一维的。改进思路就是修改Nearest()函数。使得$X_{rand}$能够更快的找到$X_{near}$

![image-20210924105757867](/home/cl/.config/Typora/typora-user-images/image-20210924105757867.png)

**怎样构造一棵Kd-tree？**

对于Kd-tree这样一棵二叉树，我们首先需要确定怎样划分左子树和右子树，即一个K维数据是依据什么被划分到左子树或右子树的。

在构造1维BST(二分搜索树)树时，一个1维数据根据其与树的根结点和中间结点进行大小比较的结果来决定是划分到左子树还是右子树，同理，我们也可以按照这样的方式，将一个K维数据与Kd-tree的根结点和中间结点进行比较，只不过不是对K维数据进行整体的比较，而是选择某一个维度Di，然后比较两个K维数在该维度Di上的大小关系，即每次选择一个维度Di来对K维数据进行划分，相当于用一个垂直于该维度Di的超平面将K维数据空间一分为二，平面一边的所有K维数据在Di维度上的值小于平面另一边的所有K维数据对应维度上的值。也就是说，我们每选择一个维度进行如上的划分，就会将K维数据空间划分为两个部分，如果我们继续分别对这两个子K维空间进行如上的划分，又会得到新的子空间，对新的子空间又继续划分，重复以上过程直到每个子空间都不能再划分为止。以上就是构造Kd-Tree的过程，上述过程中涉及到两个重要的问题：1）每次对子空间的划分时，怎样确定在哪个维度上进行划分；2）在某个维度上进行划分时，怎样确保在这一维度上的划分得到的两个子集合的数量尽量相等，即左子树和右子树中的结点个数尽量相等。

**问题1： 每次对子空间的划分时，怎样确定在哪个维度上进行划分？**

最简单的方法就是轮着来，即如果这次选择了在第i维上进行数据划分，那下一次就在第j(j≠i)维上进行划分，例如：j = (i mod k) + 1。想象一下我们切豆腐时，先是竖着切一刀，切成两半后，再横着来一刀，就得到了很小的方块豆腐。

可是“轮着来”的方法是否可以很好地解决问题呢？再次想象一下，我们现在要切的是一根木条，按照“轮着来”的方法先是竖着切一刀，木条一分为二，干净利落，接下来就是再横着切一刀，这个时候就有点考验刀法了，如果木条的直径（横截面）较大，还可以下手，如果直径较小，就没法往下切了。因此，如果K维数据的分布像上面的豆腐一样，“轮着来”的切分方法是可以奏效，但是如果K维度上数据的分布像木条一样，“轮着来”就不好用了。因此，还需要想想其他的切法。

如果一个K维数据集合的分布像木条一样，那就是说明这K维数据在木条较长方向代表的维度上，这些数据的分布散得比较开，数学上来说，就是这些数据在该维度上的方差（invariance）比较大，换句话说，正因为这些数据在该维度上分散的比较开，我们就更容易在这个维度上将它们划分开，因此，这就引出了我们选择维度的另一种方法：==**最大方差法（max invarince），即每次我们选择维度进行划分时，都选择具有最大方差维度。**==

**问题2：在某个维度上进行划分时，怎样确保在这一维度上的划分得到的两个子集合的数量尽量相等，即左子树和右子树中的结点个数尽量相等？**

假设当前我们按照最大方差法选择了在维度i上进行K维数据集S的划分，此时我们需要在维度i上将K维数据集合S划分为两个子集合A和B，子集合A中的数据在维度i上的值都小于子集合B中。首先考虑最简单的划分法，即选择第一个数作为比较对象（即划分轴，pivot），S中剩余的其他所有K维数据都跟该pivot在维度i上进行比较，如果小于pivot则划A集合，大于则划入B集合。把A集合和B集合分别看做是左子树和右子树，那么我们在构造一个二叉树的时候，当然是希望它是一棵尽量平衡的树，即左右子树中的结点个数相差不大。而A集合和B集合中数据的个数显然跟pivot值有关，因为它们是跟pivot比较后才被划分到相应的集合中去的。好了，现在的问题就是确定pivot了。给定一个数组，怎样才能得到两个子数组，这两个数组包含的元素个数差不多且其中一个子数组中的元素值都小于另一个子数组呢？**方法很简单，找到数组中的中值（即中位数，median）**，然后将数组中所有元素与中值进行比较，就可以得到上述两个子数组。同样，在维度i上进行划分时，pivot就选择该维度i上所有数据的中值，这样得到的两个子集合数据个数就基本相同了。

解决了上面两个重要的问题后，就得到了Kd-Tree的构造算法了。

**Kd-Tree的构建算法：**

（1） 在K维数据集合中选择具有最大方差的维度k，然后在该维度上选择中值m为pivot对该数据集合进行划分，得到两个子集合；同时创建一个树结点node，用于存储；

（2）对两个子集合重复（1）步骤的过程，直至所有子集合都不能再划分为止；如果某个子集合不能再划分时，则将该子集合中的数据保存到叶子结点（leaf node）。

以上就是创建Kd-Tree的算法。下面给出一个简单例子。

给定二维数据集合：(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)，利用上述算法构建一棵Kd-tree。左图是Kd-tree对应二维数据集合的一个空间划分，右图是构建的一棵Kd-tree。

![image-20210924142413731](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142413731.png)

**Kd-Tree与一维二叉查找树之间的区别：**

二叉查找树：数据存放在树中的每个结点（根结点、中间结点、叶子结点）中；

Kd-Tree：数据只存放在叶子结点，而根结点和中间结点存放一些空间划分信息（例如划分维度、划分值）；

 

**构建好一棵Kd-Tree后，下面给出利用Kd-Tree进行最近邻查找的算法：**

（1）将查询数据Q从根结点开始，按照Q与各个结点的比较结果向下访问Kd-Tree，直至达到叶子结点。

其中Q与结点的比较指的是将Q对应于结点中的k维度上的值与m进行比较，若Q(k) < m，则访问左子树，否则访问右子树。达到叶子结点时，计算Q与叶子结点上保存的数据之间的距离，记录下最小距离对应的数据点，记为当前“最近邻点”Pcur和最小距离Dcur。

（2）进行回溯（Backtracking）操作，该操作是为了找到离Q更近的“最近邻点”。即判断未被访问过的分支里是否还有离Q更近的点，它们之间的距离小于Dcur。

如果Q与其父结点下的未被访问过的分支之间的距离小于Dcur，则认为该分支中存在离P更近的数据，进入该结点，进行（1）步骤一样的查找过程，如果找到更近的数据点，则更新为当前的“最近邻点”Pcur，并更新Dcur。

如果Q与其父结点下的未被访问过的分支之间的距离大于Dcur，则说明该分支内不存在与Q更近的点。

回溯的判断过程是从下往上进行的，直到回溯到根结点时已经不存在与P更近的分支为止。

 

**怎样判断未被访问过的树分支Branch里是否还有离Q更近的点？** 

从几何空间上来看，就是判断以Q为中心center和以Dcur为半径Radius的超球面（Hypersphere）与树分支Branch代表的超矩形（Hyperrectangle）之间是否相交。

在实现中，我们可以有两种方式来求Q与树分支Branch之间的距离。第一种是在构造树的过程中，就记录下每个子树中包含的所有数据在该子树对应的维度k上的边界参数[min, max]；第二种是在构造树的过程中，记录下每个子树所在的分割维度k和分割值m，（k, m），Q与子树的距离则为|Q(k) - m|。

 

以上就是Kd-tree的构造过程和基于Kd-Tree的最近邻查找过程。

下面用一个简单的例子来演示基于Kd-Tree的最近邻查找的过程。

数据点集合：(2,3), (4,7), (5,4), (9,6), (8,1), (7,2) 。

已建好的Kd-Tree：

![image-20210924142513943](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142513943.png)

查询点： (8, 3) （在左图中用茶色菱形点表示）

第一次查询：

![image-20210924142913148](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142913148.png)

当前最近邻点： (9, 6) ， 最近邻距离： sqrt(10)，

且在未被选择的树分支中存在于Q更近的点（如茶色圈圈内的两个红色点）

 

回溯：

![image-20210924142934628](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142934628.png)



当前最近邻点： (8, 1)和(7, 2) ， 最近邻距离： sqrt(2) 

最后，查询点(8, 3)的近似最近邻点为(8, 1)和(7, 2) 。

**==另一种优化方法：==**

![image-20210924143957107](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924143957107.png)



**撒一次点，同时完成两颗树的构建，当$X_{new}$同时连接了两颗树时，路径构建成功。**

==**另一种在narrow passage环境的优化方式：**==因为在狭窄通道内采样点很少，所以对于终点是在narrow passage中的情况，可以在narrow passage中生成一棵树。

![image-20210924144437003](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924144437003.png)



## 3.3 基于采样的最优路径规划算法

Optimal sampling-based path planning methods

为了解决RRT生成路径不是最优的问题，故有了RRT*算法。

![image-20210924145415041](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924145415041.png)



不同于RRT，RRT*算法找到$X_{new}$之后是没有直接扩展到树中的。而是通过NearC函数找到$X_{new}$附近的一些邻域节点（以一定的半径来找），然后通过线段和$X_{near}$连接起来。

然后找$X_{new}$的父节点，计算准则：从起始点到$X_{new}$，可以通过$X_{near}$到，也可以通过$x_1$或$x_2$到。代价函数就是路径最短。

所以这个时候$X_{near}$就被选择为父节点。然后把这父节点、$X_{new}$点和边扩展到树中。

![image-20210924151016473](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924151016473.png)

**==rewire()函数：剪枝过程（局部重连接）。==**

如下图所示：蓝色的线段如果比红色的线段短，那么$x_2$就修改父节点，原来的父节点是$x_1$，现在修改为$X_{new}$。

**剪枝过程不断进行，从而使树不断优化，从而使找到的目标路径越来越短。**

所以RRT*算法,找到目标路径之后，不会立刻停止，会持续不断地优化。

![image-20210924152115575](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152115575.png)

![image-20210924152405181](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152405181.png)

==**Kinodynamic-RRT*:直线路径对于很多机器人是没法完成的（比如车需要往前走，才能完成水平方向的位移）**==

用曲线代替直线，使之更符合机器人的运动。

![image-20210924152857462](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152857462.png)

用曲线代替直线，可能会出现一些有意思的问题：比如有些原本会出现碰撞的线段，变成曲线后不会碰撞。

![image-20210924153244908](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924153244908.png)

目前关于Kinodynamic RRT*算法的研究有很多，比较火，集中在无人机、机器人的路径规划方面，考虑机器人的约束，就会有很多的问题。

**Anytime-RRT***

找到一条路径了，如何去追踪这条路径。在Anytime-RRT*的路径规划中，即使从树中找到了一条目标路径，但是这条路径仍是在动态更新的。在构建树的过程中，起始点就动态地变成了机器人的实时位置。相对于固定死的路径规划（先规划好路径再让机器人去执行）来讲，**Anytime-RRT***能更好地去适应环境变换比较大的情况。

![image-20210924155528668](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924155528668.png)

总结：![image-20210924155632632](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924155632632.png)

## 3.4 先进的采样方法

==**Informed RRT***：==

在空间里面均匀地撒点，其实很多过程是浪费的，所以把采样的过程限制在一个椭圆里面，这个**椭圆**是围绕已生成的路径产生的，从而对路径本身做优化。

![image-20210924160847204](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924160847204.png)

当路径生成之后，如何构建椭圆？

以起始点和终点作为椭圆的焦点，生成路径的长度就是代表椭圆的常数。因为随着优化的进行，路径变短了，常数越小，椭圆会变得越来越扁，所以采样的范围也会变得越来越小。从而优化的效率得到提高。

这里的优化主要是指路径最短。

![image-20210924161027414](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924161027414.png)



**==Cross-entropy motion planning==**

首先是先生成一条路径（最左边红色路径），在轨迹的六个节点的周围椭圆区域进行采样，就能得到很多条路径，这6个节点构成了多高斯模型。例如：第三幅图中，通过两次采样，得到了新的两条路径。一共有三条路径。

![image-20210924190459084](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924190459084.png)

生成了多条轨迹之后，我们对多个轨迹的多个节点，求一个均值。这个均值作为新的多高斯分布，下次采样过程就在新的高斯分布中进行采样。

![image-20210924191514953](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924191514953.png)

如下图，从左到右，展示了根据采样的不断优化，生成路径逐渐变得光滑的过程。

![image-20210924191907096](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924191907096.png)

不管是Cross-entroy还是Informed RRT*都是对采样的过程进行优化。

只要不跳出基于采样的框架，那么要改进的东西就在Sample()、Near()、Steer()函数中。

## 3.5 算法实践

Ompl库，集成了很多运动规划算法，但是场景更偏向于机械臂。

Navigation stick ，专门设计为移动机器人用的库。

![image-20210924193124281](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924193124281.png)

在ROS中实现RRT*程序时，需要对OMPL库有一定的了解。程序中都用到了这些基础类。

![image-20210926164143601](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926164143601.png)

# 4.动力学约束下的路径规划

在前几课中，是不考虑机器人的运动学模型的。考虑了机器人的运动学模型之后，也可以分为基于搜索的和基于采样的。

![image-20210926165157682](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926165157682.png)

## 4.1 总体介绍

Kinodynamic:合成词，是由运动学+动力学组成的。

定义：是一种生成机器人的运动，同时受限于运动学的约束：避障，和动力学的约束：比如说在速度、加速度和机器人产生的力的上下限的约束。

特点：受到高阶模型的约束(微分)，加速度约束。

![image-20210926165250172](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926165250172.png)

问题：既然有后端优化，为什么在前端动力学搜索的时候，还需要考虑机器人的高阶动力学约束呢？

答：如果在前端考虑，后端的压力就会减轻。不能在前端粗暴的找路径，不考虑任何的动力学。

![image-20210926170151893](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926170151893.png)



轨迹优化是局部的，换句话说，你很难把一个轨迹，在从障碍物的左侧，给它优化到另一侧。例如：下图中无人机有朝右侧的初速度，最好的轨迹应该是右侧绿色虚线（优化后），而如果只考虑质点模型，就可能产生紫色实线的路径，轨迹优化后产生在障碍物左侧的紫色虚线路径。

考虑动力学和不考虑动力学，产生的轨迹拓扑是有很大区别的。

![image-20210926170719794](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926170719794.png)

## 4.2 状态栅格规划器State Lattice Planning

两种方法：

1.前向方法：把机器人的控制空间进行离散，驱动机器人往前运动。

2.逆向方法：离散机器人的状态空间。

![image-20210926182516097](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926182516097.png)

如下图，在栅格地图中，让机器人进行4连接或8连接的运动，实际上是对控制空间的离散。

![image-20210926182800938](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926182800938.png)

采样实质是对状态空间的离散。

![image-20210926183228193](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926183228193.png)

1.离散控制空间：给定初始状态，选择控制输入，给定一段时间，前向模拟。

2.离散状态空间：如下图，在状态空间中，我采样到了t1时刻的状态，(x,y)。逆向计算出我在t0时刻应该怎样踩油门打方向盘持续多久，才能得到这样一条轨迹。

这样天然地具有启发性，具有贪心的性质，我想让车开到哪里，可以很明确的知道。

![image-20210926190707491](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926190707491.png)

无人机：双积分模型，在控制空间中采样。系统在不同的输入激励下，保持一定的时间，演化出不同的状态。

Jerk：加速度的导数，如果拿jerk作为控制输入的话，那么加速度也要放在状态空间里了。那么是三阶积分系统

紫色的曲线，就代表了状态转移过程。

![image-20210926193239428](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926193239428.png)

A矩阵的特殊性质：nilpotent幂零矩阵，有很好的特性，可以让计算变快，缩短planning的时间。我们非常看重它。

$A^i=0$当i超过几次之后，就变成0了

**我们怎样还原出过程的轨迹呢?这就涉及到状态转移方程。**

无人机系统，前向积分的函数表达式。$S(t)$随着时间变化的函数，$F(t)$零输入响应，$G(t)$零状态响应。$u_m$控制输入。

给定一个具体的时刻t1，具体的$S(t1)$怎样计算，就很头疼，

$e^{At}$:状态转移矩阵,关于它的计算，一般会将它做展开（无穷级数），如果A是幂零矩阵，那么后面的项就可以舍弃。极大地简化计算。

![image-20210926194406984](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926194406984.png)

左图：每个边做9次离散化，右图：每个边做25次离散化。这样的图称做Lattice Graph

![image-20210926195453048](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926195453048.png)

与无人机的思路一样，先从搜索树中挑选一个模型，选择控制输入，给定一定的时间，得到一条轨迹，如果无碰撞就添加到结果中。

![image-20210926202344260](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926202344260.png)

说完了控制空间中的离散化，然后是状态空间的离散化。

给定一个状态，反算它们中间的连接方式，就可以算出来很多边的连接。



**比较**：在控制空间里采样是很没有目的性的。很多离散控制量产生的feasible motion connections,会开到路外面去，是不可用的。

但如果是在状态空间里采样，是可以保证落在马路上的，因为是根据结果反算的。效率也高。

但是状态空间采样非常难实现。**给定了初始状态和末尾状态，到底怎么把中间路径给算出来**，这就涉及到解边界值问题：

**==Boundary Value Problem(BVP)==**

![image-20210926203123871](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926203123871.png)

以无人机为例，求解边界值问题：

![image-20210927090309268](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927090309268.png)

对$x(t)$做参数化，五阶多项式，假设在边界时刻，速度、加速度都是0。然后要解出$x(t)$的参数${c_5,c_4,...,c_0}$

对于$x(t)$的两个边界条件，代进去；然后一阶导：速度，两个状态，代进去；二阶导：加速度，两个状态，代进去。

得到6个方程。最后解方程组。

**获得一个BVP问题的解不是很困难，但是获得一个最优的BVP解是很困难的。**

![image-20210927090331152](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927090331152.png)



**目标：对于无人机系统，我希望jerk的平方项在一定时间长度上的积分是最小的。**

**$J_k$中的k代表某个轴，这里将无人机planning的x,y,z轴分开独立进行，简化问题。**

系统的状态：${p,v,a}$，输入:$j=u$

系统模型：积分模型，由系统状态求导而来。

解决方法：利用极小值原理去求解最优控制的问题。

![image-20210927091536563](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927091536563.png)

庞特李亚金的极小值原理：庞特里亚金极小值原理是在控制向量u(t)受限制的情况下，使得目标函数J取极小，从而求解最优控制问题的原理和方法，又称极小值原理。λ是协态向量，系统模型有多少个变量就有多少个协态。s和u都是省略了符号t的，代表某一时刻的最优状态和最优控制，是一个常数。利用庞特里亚金极小值原理**求解最优控制问题首先需要求解协态方程，也就是λ，然后再求解最优控制u*，求解完u*之后，即可得到最优状态。**

目标函数J由两部分组成，第一是末状态的惩罚项$h(s(T))$,就是说希望T时刻无人机的状态逼近期望；第二项：是整个T时刻，机器人运动的能量损耗。

最后要求解的是最优状态$S^*(t)$和最优输入$u^*(t)$。

这个协变量λ是微分方程：哈顿函数的解,在其中的状态$S^*(t)$和控制输入$u^*(t)$都取到了最优解的时候，对里面的S求一个偏导数，再取负号。



![image-20210927092734613](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927092734613.png)

3. 求解最优控制
根据庞特里亚金极小值原理中的：![image-20210927112430049](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927112430049.png)

最优的u*的选取是，当哈密顿函数中的s取最优时，能够使得哈密顿函数最小的那个u即为最优控制量。令导数等于0即可。
**求解出最优输入和最优状态轨迹：**最优输入求出来之后，状态就是输入做积分。分别积分一次、二次、三次得到。

那么最后只差$\alpha,\beta,\gamma$三个常数值没确定。

![image-20210927100445468](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927100445468.png)

**这三个常数用最后末尾时刻的边界条件来确定**。把末尾时刻T代进去，$s^*(T)=s_f$。

可以算出，$\alpha,\beta,\gamma$三个参数只跟T相关，进一步可以得出，代价J也只跟T相关。

所以，在状态空间内的采样问题，**只要给定初始状态、末尾状态、时刻T，那么所有的东西全都可以计算出来了。**

J只依赖于T，所以变成了一个单变量多项式求极值的问题。即$f'(T)=0$的问题。就变成了多项式求根的问题，所以就变得很快了，可以用很小的代价就把最优的T求出来。

![image-20210927101128034](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927101128034.png)



对于末状态部分指定的问题，即（p,v,a）只要p达到，va可以自由指定的问题。那么λ(t)的边界条件是存在的,对于不是给定的状态分量。

![image-20210927102456229](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927102456229.png)

贪心的设计原则：

![image-20210927105550812](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927105550812.png)

## 4.3 Hybrid A*

一种具体地机器人实时地Kinodynamic路径规划算法（基于搜索的方法）。prune:剪枝

**工作流程：**

lattice图：离散输入时，比如分成20份，会导致图非常稠密，当一条边遇到障碍物时，会导致它邻近的边也一起遇到障碍物了。那就自然想到能不能对图做一个剪枝。

随着向前积分，从一个网格出现到另一个网格（红点），如果有多个状态线都到了同一个网格，选取cost最小的那一根进行更新。永远只保持一个网格里只有一个节点。

![image-20210927112635013](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927112635013.png)

找邻居的不同：Hybrid A$*$是找周围的邻近状态，而A*是找周围邻近的八个点，而JPS是打破对称性，跳点寻找。

![image-20210927145305307](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927145305307.png)

如何合理的设计启发式函数？

**non-holonomic 非完整约束。**

**holonomic:完整约束。**

![image-20210927150659964](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927150659964.png)

其他技巧：随着树离终点越来越近，是不是可以通过一次one shot尝试，直接解算出到终点的路径（解一个最优控制问题）

![image-20210927151909238](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927151909238.png)

Fast-planner用的就是Hybrid A*算法。nilpotent:幂零矩阵

![image-20210927153341046](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927153341046.png)

## 4.4 Kinodynamic RRT*

第一个不同：选择父节点时的区别：当Kiondynamic RRT*找到了自己的父节点之后，连接两点之间的状态线不再是直线，这就是求解一个最优两点边界值OBVP问题，

![image-20210927155240191](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927155240191.png)

第一步：怎样采样“Sample”，不能像RRT一样，只在位置空间（x,y,z）采样了，要求在全状态空间采样，例如二阶系统就是（p,v）

![image-20210927155810303](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927155810303.png)

第二步：用最优控制的知识，把新采样的state和最邻近的state，做一个连接。（比如根据前面的极小值原理。）

![image-20210927160058060](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160058060.png)

那么如何做一个最优控制的连接呢？（另一种方法）：两种状态是near的当它们状态转移时cost最小。

![image-20210927160452296](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160452296.png)

第三步：怎样选择父节点。在高维的状态空间里，找一个state，使得

![image-20210927160834666](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160834666.png)

前向可达集，后向可达集？

![image-20210927162005387](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927162005387.png)

![image-20210927162131269](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927162131269.png)

## 4.5 算法实践Local Lattice planner

Local State Lattice Planner作业：

包括求解最优边界问题（BVP），找出最小代价。

节点图：

![image-20210927200227729](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927200227729.png)

结果图：

![image-20210927200246767](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927200246767.png)

# 5.Minimum Snap Trajectory Generation轨迹生成

## 5.1 总体介绍

从前端Path Finding->后端Trajectory Generation

为什么需要一条光滑轨迹呢？

1.首先适合机器人运动

2.速度或更高阶的动力学量不能突变。

3.机器人不应该突然刹车或转弯

4.节能

![image-20210923163559813](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923163559813.png)

问题：已经有了前端，为什么还需要后端？

答：后端为了做优化，得到一条轨迹，适合机器人执行。

问题：前端已经是动力学可行的了，为什么还需要轨迹优化呢？

比如：下图红色曲线，是Hybrid A*生成的，而蓝色曲线是优化后的，很明显更加光滑。这就是轨迹优化的作用。

整个框架一定是满足一个coarse->fine 从粗到精的过程。

![image-20210928143047976](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928143047976.png)

边界条件：要满足当前机器人运动的起始状态，也可以指定运动的末状态

中间条件：waypoint 一般指中间节点，这些中间点可以是你前端路径搜索出来的。也可以是人为指定的，比如巡检任务。

轨迹是否光滑的评价准则：需要一个评价函数，来评价轨迹是否光滑，经过路标点的时候，轨迹在这个点的左极限和右极限是连续的。

**对于多路标点的轨迹生成的问题：往往会把它变成分段轨迹求解的问题。**

![image-20210923163859801](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923163859801.png)



## 5.2 Minimum snap Optimization

微分平坦：一个移动机器人系统，可以把它在全维度的状态空间的planning问题，转变成在低维的，进行挑选过后的，平坦的flat output输出空间里来进行轨迹规划。它的要求是**==我们整个的状态空间，都可以被平坦空间里的变量以及变量的各阶导数，进行代数表示。==**

在无人机系统中，在很多年前的控制工作里，已经证明了，可以通过精心设计一个在SE(3)上的几何跟踪控制器，可以使得所有在flat output空间里生成的轨迹，如果这些轨迹的各个状态及它们的导数是合理的bounded住，(合理:指的是不会快速发散)，这样生成的轨迹一定是可以被跟踪的。

![image-20210928150744180](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928150744180.png)

对于无人机12维的状态空间来说，它的平坦空间是四变量的空间。

**牛顿方程：表达平移量的运动。**

左边：world系下的合外力，ma；右边：重力+四轴的合外力。飞机的推力合力方向一定是垂直于桨平面的，所以在机体系下的合力为u1。

**欧拉方程：表达转动量的运动。**

u2、u3、u4是力矩。

这个牛顿欧拉方程的详解过程见链接：

https://zhuanlan.zhihu.com/p/396756903

https://zhuanlan.zhihu.com/p/47868515

![image-20210928151916588](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928151916588.png)

**证明：确实可以把无人机12维的状态空间，压缩到4维平坦空间${x,y,z,\psi}$。**

即所有其他变量可以被这四个变量以及它们的导数代数组合。

**无人机的加速度和它的姿态是绑定的，所以规划它的加速度和规划它的姿态，两者只能取其一。因为姿态存在比较强的非线性，所以一般来说，还是选取加速度去做planning。**

对于无人机来说，是没有机头这个概念的。**相对来说，偏航角是独立的，因为不管是任何偏航角，推力是不受影响的。**

首先先位置与线速度，线速度是位置的导数，所以本身就在平坦空间里了，故线速度不用再证明。

![image-20210928154425190](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928154425190.png)

接下来，就要花力气看无人机的姿态。无人机的姿态靠三轴的方向来描述（因为欧拉角是通过绕三轴旋转得到的）

t就是三轴合加速度（$\delta_1,\delta_2,\delta_3$就是x,y,z），所以Body系的，Z轴的方向$Z_B$已经得到。

$X_C$是为了方便引入了中间坐标系，它和$X_w$只差了一个偏航角$\psi$。所以就可以用$\psi$(即$\delta_4$)表示出$X_c$

$Y_B$显然可以由$Z_B\times X_c$得到

![image-20210928172103264](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928172103264.png)

那么姿态搞定之后，现在只剩下角速度了。

我们还是从四旋翼无人机的运动公式着手，后一项$w_{BW}$涉及到对旋转的坐标系$Z_B$求导。

推力的导数：等于无人机整个合力的导数，$Z_B$表示方向。

把$\dot{u_1}$代入运动方程，可以得到$h_w$,是一个暂时自己定义出的物理量，先不管它的具体含义。这个量现在就是被flat output代数表示出来的。

![image-20210928175824247](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928175824247.png)

那么继续推导，现在已经有了$h_w$这样一个中间量，那么又有$w_{BW}$的表达式，显然$X_B \times Z_B = - y_B$，将$w_{BW}$代入$h_w$中，就可以得到$w_x,w_y$了。

![image-20210929101006248](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929101006248.png)

那么现在只剩下$w_z$这个漏网之鱼。

![image-20210929101545220](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929101545220.png)

那么现在已经全部搞定了。那么接下来你只需要记住：接下来我们对无人机的运动规划一定是在${x,y,z,\psi}$以及它们的导数上进行。

![image-20210929091326626](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929091326626.png)

那么我们最后给无人机生成的轨迹指令呢，==**我们实际上就是规划出，${x,y,z}$以及一阶二阶导数和${\psi}$,**==控制的时候呢，位置控制器会计算出期望的姿态，然后交给姿态控制器，位置控制器解算出推力$u_1$，姿态控制器解算出三个方向力矩$u_2,u_3,u_4$，然后最后真实的去控制无人机。

![image-20210923170157388](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923170157388.png)

接下来看轨迹的表示形式，和我们在OBVP问题中一样，算出来的**==轨迹实际上就是一个多项式==**。

多项式函数非常容易定义光滑准则。多项式函数易于计算各阶导数。多项式函数非常容易在三个轴上进行解耦。

![image-20210929103637990](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929103637990.png)

首先对于一维的一段轨迹来说，多项式提供了一个轨迹光滑的保证，因为多项式是多阶可导的。

光滑是表示可导，比如说我们想要轨迹的速度是光滑的，那么前提是速度的导数加速度，至少要是连续的。

多项式提供了这样一个便利，可以在它的阶数内进行多次求导，天然地就是光滑的。

![image-20210923164005036](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164005036.png)

这里的缺点是，缺少中间条件。对于移动机器人来说，它的中间轨迹点，速度、加速度肯定不是0，所以至少要给定一个指定的值。

![image-20210923164110116](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164110116.png)

我们期望在中间的waypoint有一个定值v

![image-20210929105401697](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929105401697.png)

这里就涉及到一个问题：为什么速度、加速度是人为指定的？如果是人为指定的，应该指定成多少才是合理的？

对于一个复杂的问题来说，其实完全无法预测移动机器人以什么样的速度、加速度到这个点才是最好的。所以往往是不能指定v和a的。

这就是我们要用优化的方式来做的了，**==用优化的方法来算一个最佳的到达这些位置的v和a。==**

![image-20210923164418608](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164418608.png)

接下来用无人机举例，**==怎么用Minimum Snap来求解v和a==**。

**==我们反复强调了无人机的加速度和姿态（旋转）是绑定的。角速度和推力是对应的。==**

![image-20210929110302949](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929110302949.png)

由这个我们就可以得到一个指标：如果最小化无人机的jerk，相当于最小化了角速度。

那么**最小化角速度有什么好处**呢？大家都知道，无人机常用视觉导航，举个例子，如果让摄像头原地旋转，那么视差是变化的非常快的，跟只有平移量是不一样的，此时VIO是很容易挂掉的，==**那么最小化角速度，其实就是最小化视差的变化率，一般认为对视觉的跟踪是有好处的。**==

那么最小化Snap呢？因为snap是对应推力的导数，一般认为**==它使得推力的变换尽可能的平缓，所以节省能量==**。

![image-20210929110410976](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929110410976.png)

那么现在目标已经明确了，就是要计算分段多项式（是轨迹多项式的导数）的系数，使得总体的轨迹是光滑的。使得分段多项式满足边界条件，经过中间点，中间点的轨迹前后段的左右极限是高阶导数都是一样的。

![image-20210929111347159](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929111347159.png)

轨迹分段多项式的形式如下：

1.每一段轨迹都是多项式

2.不一定要强调每一段轨迹的多项式阶次是一样的，但如果是一样的阶次会使得问题更简单。

3.每一段轨迹的时间一定要是已知的。

![image-20210929111746008](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929111746008.png)



![image-20210923181338817](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923181338817.png)

![image-20210923181821132](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923181821132.png)

Minimum Snap轨迹需满足边界条件约束和连续条件约束。

![image-20210929112232532](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929112232532.png)

怎么合理地选择轨迹的阶数呢？

确保k阶是光滑的，k+1阶是连续的。最小化控制输入的几阶导数

![image-20210929112318880](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929112318880.png)

对于选择多项式的阶数，一般会有一些工程上的约定：对一段轨迹而言，**==Minimum jerk:需要5阶多项式==**；起点（位置、速度、加速度）三个未知量，终点也是三个未知量，一共6个未知量，那轨迹参数化的方程就要提供这6个自由度，才可以求解6个未知量。一个五次多项式就有6个未知量(因为有个常数项，从零次开始计算)。

==**同理Minimum snap:需要7阶多项式。**==

对k段轨迹而言：有k-1个分段点，对于Minimum jerk来讲，起点和终点各有三个约束，在每一个分段点只要求它的位置，而v和a是优化出来的，不叫约束。所以总约束量是k+5;

假设每一段轨迹的阶数是N，每一段轨迹可以提供未知数的自由度就是N+1,如果让这个问题有解，那么就是自由度要大于等于变量数。

所以最低的阶数情况下，也是$(N+1)*k=k+5$,求得$N= 5/k$,所以轨迹的段数越多，相对来说每一段轨迹需要提供的未知数越少。阶次就可以越低。

因为不知道前端在path finding这个步骤会给你返回多少个节点，甚至它可以只返回一个起始点，一个最终点。==一般来说，为了保险，都是按一段轨迹来设计多项式的阶数。==

![image-20210929143915930](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929143915930.png)

还有一点要强调的就是，时间线的问题。时间线决定了你分段轨迹的形式。

像下图第二种，就是一种全局的时间线。但是这种方式很脆弱，数值不稳定。

另一种，就是相对时间轴，这种在数值上会比较稳定。

![image-20210929150626999](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929150626999.png)

多项式的代价函数，**最后的化简形式就是一个二次型**。

中间矩阵$Q_j$称为Hexian矩阵。**权重矩阵Q的求解方法：见中间矩阵的公式和MATLAB作业代码。**

![image-20210929151302175](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929151302175.png)

目标函数得到之后，就要对我的优化问题施加一些约束，**==这里是导数约束。就是位置$p(t)求导可以得到v(t) a(t) jerk(t) snap(t)$。==**

![image-20210929152208623](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929152208623.png)

还有两段轨迹之间的**连续性约束**：我们希望轨迹保证首尾的边界约束，以及中间，每一段轨迹的临界导数一定经过中间的某个点。

前一个时刻的某阶导数跟后一时刻的某阶导数是相等的。

最后还是一种等式约束形式。

![image-20210929152719091](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929152719091.png)

最后把所有的约束整合在一起，形成一个大的等式约束。

**问题的目标函数：每一段轨迹都是一个跟自己当前段系数相关的二次型，把每一段加在一起，==中间的权重矩阵就变成了对角矩阵==。**

这个问题就叫做二次优化问题-QP问题。**这就是一个等式约束二次规划问题**。这就是一种非常标准的凸优化问题。代表一定可以求解。

**凸优化问题是一定可以在多项式的时间复杂度的时间内求解出这个问题的全局最优解。**

![image-20210929153348981](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929153348981.png)

在做轨迹优化的时候，经常需要用到凸优化。

![image-20210929153919867](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929153919867.png)

什么叫凸函数，什么叫凸集合？

**如果函数图形如下左图所示，那就是凸函数。反过来就是凹函数concave。**

数学上的定义：如果在凸函数上取两个点，再在这两个点的中间取一个点，那么中间点的凸函数值是小于这两个点的凸函数值加权平均的。

凸函数为什么重要：如果一个函数是凸的，那么从任何一个起点开始，（只要是处处可导的），那一定可以按梯度方向下降，前进到全局最低点，如果梯度上升了，此时得到最优值。绝大多数函数其实并不是凸函数，存在很多局部极小值。用基于梯度的方法解出来的解可能是局部极小值。那凸函数的话呢，就保证了解出来的值都是全局极小值。

凸集合，**假设有一个集合，从这个集合里任意取两个点连成线，这条线上的每一个点，都仍然在这个集合里，就叫凸集合**。取两个点连成线，中间有很多点落在外面，就叫非凸集合。

![image-20210929154103278](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929154103278.png)

对于优化问题呢，首先定义什么叫优化问题？

**首先有一个目标函数，受一些约束**：不等式约束、等式约束等。要优化的变量都提到了x里。

==**什么叫凸优化问题**：==**首先目标函数要是凸函数。它的不等式约束一定是凸函数，以及它的等式约束一定是Affine形式。**（仿射变换形式）x的定义域一定要是一个凸集。

凸优化问题有很多理论在其中，有的问题看上去不是凸的，但可以经过一些数学变换，变成一个等价的凸优化问题，从而求解它的最优解。这是一门艺术。

![image-20210929161039394](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929161039394.png)

当你把问题化简成了一些规则严明的凸优化问题形式之后，你就可以认为这个问题一定是好求解的。

线性优化，二次优化，二次约束的二次优化问题QCQP，二阶最优化问题SOCP。

**变成了QP问题之后，用求解器去求解。是数值解。**

![image-20210929164424078](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929164424078.png)

**==关于Minimum Snap轨迹规划问题的两种求解方法：详见如下链接。==**

**https://blog.csdn.net/liuerin/article/details/117324253**

## 5.3 Closed-form Solution to Minimum Snap

这种形式是直接求QP问题的解析解。

决策变量的转换：把优化问题从优化多项式的系数$P_0-P_5$，（这样一种没有实际物理意义的，比较不稳定的）决策变量，转变成优化在轨迹上中间点的v和a，作为决策变量。

为什么这样会稳定呢？因为这些v和a是有明确物理含义的，不会出现特别奇怪的值。

所以首先要构造的是映射矩阵，**把这个问题里，所有待求解的变量P，通过映射矩阵映射成在每一段轨迹所有两端端点上的各阶导数。即$M_jP_j=d_j，可以得出P=M^{-1}d_j$。**

![image-20210929165510411](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929165510411.png)

到了这一步，把所有的P已经换成d了。

![image-20210929171230646](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929171230646.png)

**==Minimum Snap闭式解法的核心思想就是：把这个问题里要优化的变量和已经固定的变量，做一个分解。==**

闭式法的思路是：将d向量中的变量分成两部分：”d中所有已知量组成的Fix部分$d_F$”和”所有未知量组成的Free部分$d_P$"。然后通过推导，根据$d_F$求得$d_P$，从而得到d，最后求得p 。
使得$d=C[\begin{array}{cc|r} d_F \\ d_p \end{array}]$

分解的方法：关键是构造一个选择矩阵，乘以要分解完的结果，得到是原来已有的端点的导数的排列。

把所有不能动的$d_F$排到前面去，把所有可以动的$d_P$排到后面。

![image-20210929172839026](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929172839026.png)

现在看一下，怎么构建选择矩阵：蓝色线段是二段轨迹，虚线框内前一组是fixed的，后面三组都是$d_p$的。那么在构建C的时候呢，

等号的左边呢，全部加起来，一共有16个。等号右边呢，因为中间两组是重叠的，实际上只有12个。

接下来就是怎样在C里面的某些位置填上1，使得两边相等。

比如$d_{T,1}^{(0)}$和$d_{0,2}^{(0)}$它们对应的是同一个固定变量，它们俩都会填上1

写closed-form形式，关键就是构造这样一个选择矩阵C。

![image-20210929183913691](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929183913691.png)

![image-20211014092053327](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014092053327.png)





层级式方法，先用RRT*找到一条路径，记录下RRT*中间的waypoint，把路标点作为Minimum Snap的中间点。

path planning是在低维空间里进行，trajectory generation是在高维空间里生成轨迹。

![image-20210929185828579](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929185828579.png)

有一个问题是：在进行轨迹生成的时候，是没有障碍物的信息的，那么如何保障轨迹是安全的呢？

因为生成轨迹的时候，往往会有一个超调overshot，这个超调完全有可能会碰到障碍物。

![image-20210929185806693](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929185806693.png)

下图中蓝色是轨迹，紫色是RRT给出的Path。

解决方案：通过在Path中间插入新路径点，再重新去生成Minimum Snap轨迹。如果还有碰撞，就再次在path中间新增路径点。这样的效果就是轨迹会不断地逼近你前端找出来的那条绝对安全的Path。插点过多会导致没轨迹那么Smooth。

![image-20210929191832202](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929191832202.png)

论文的实验效果。

![image-20210929192520616](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929192520616.png)

有没有更好的解决方法呢？前述的方法是一种工程上的策略。

![image-20210929193056763](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929193056763.png)

更好的一种方案：基于硬约束的轨迹优化，这里的硬约束就是空间里的一种BoundingBox的轨迹约束，这个BoundingBox已经把障碍物排除在外了，所以轨迹生成在BoundingBox里肯定也不会发生碰撞了。

![image-20210929193147295](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929193147295.png)

对于现在有BoundingBox的约束呢，同样的，首尾两端状态要满足等式约束，中间的点（我们希望轨迹是在BoundingBox里的），会带来一个不等式约束。因为要在方块里，连续性约束同样也有。

边界约束，动力学约束：约束无人机的速度和加速度大小。

因为约束都是都是线性的，所以仍然是一个QP问题。

![image-20210929195621315](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929195621315.png)



![image-20210929201055225](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929201055225.png)

## 5.4 工程实践细节Implementation Details

首先是QP问题的求解器，OOQP非常快，而且代码是开源的。但是它是比较古老的，代码不是那么面向对象，手册也不是很健全。所以需要在网上搜一些代码，看看OOQP的slover应该怎么写。GLPK也非常快且鲁棒。

![image-20210929201255943](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929201255943.png)

数值稳定性：

除此之外，还有其他的问题。**比如时间轴的问题，是相对时间轴还是全局时间轴**，如果用全局时间轴的话，比如在某段轨迹，是105s，如果是5次多项式的话，105的五次方就是很大很大的数了，所以很容易出现数值不稳定的问题，所以解决方案就是用相对坐标轴。但他仍然解决不了，某段时间很长，某段时间很短的情况，依旧会出现很小的数或很大的数，所以要做**==归一化==**。

把每一段轨迹都给定义在是【0，1】上的多项式，然后再进行放缩。这就使得鲁棒性提高很多。

另一个问题：空间要不要进行归一化。相当于把长轨迹等比例缩小。

![image-20210929201645625](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929201645625.png)

其他的工程问题：

1.到底要不要三轴独立去解？

2.闭式解解法是不是一定更好？因为涉及到矩阵求逆的运算，运算量很大，对于嵌入式设备来讲，往往不会选择这样的方式。

3.是否多项式函数可以做所有的事情？几乎，但并不是全部。

![image-20210929203218782](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929203218782.png)

时间分配问题：Minimum Snap轨迹生成问题中，T是要指定的，那一般怎么去给一个最优的T呢？

如下图所示：如果T给的不合适，就会像蓝色曲线一样，如果合适，就像中间那样顺滑。

![image-20210923182558336](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923182558336.png)

一个非常幼稚的解法就是说：根据事先给定好的期望的速度曲线（梯形曲线），假设在每一段轨迹都满足这个速度曲线，然后可以根据这个速度曲线，和每段轨迹的长度d，计算出每段轨迹的所需时间。不过显然这种方法不是最优的。

![image-20210929203459991](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929203459991.png)

如果对于有BoundingBox方块约束的，我们是允许路标点在重合区域内移动的，提高了解的自由度，会在一定程度上缓解时间分配不好带来的问题。

![image-20210929204239961](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929204239961.png)

一种比较好的方式是：先前生成轨迹只是考虑最小化消耗能量，从来没有考虑过时间，那完全可以把时间加入到目标函数内。那这个问题怎么去优化是一个问题？因为前面一项是包含了T的，实际上这个函数是没法对T解析式的求导的。

那应该怎么做呢？可以数值求导，对每一个变量增加一个小的扰动，相当于在数值上做一个差分，有了导数就沿着梯度做下降。但这种方法是很耗时的，没法在线去用。

![image-20210929204557699](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929204557699.png)

通过给时间权重的结果如下：

![image-20210929205159265](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929205159265.png)

## 5.5 Homework

![image-20210929205706201](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929205706201.png)





# 6.软约束和硬约束下的轨迹优化

值得参考的第6章内容学习博客：https://blog.csdn.net/weixin_44558122/article/details/117534794

![image-20211014145543241](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014145543241.png)

## 6.1 总体介绍

Minimum Snap优化方式的缺陷：适合生成光滑曲线，但是不适合避障。**因此这节课的重点，就是怎样去修改Minimum Snap，使得它可以避障。**

![image-20211003120515086](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003120515086.png)



一种方式是，给障碍物施加一个推力，把轨迹往没有障碍物的地方去推，使轨迹存在于环境里的可通行区域（实际上人工势场法就是一种软约束的方法）。

同样地，也可以**在free-space里加约束**，**把轨迹吸引到安全的可通行区域free-Space里**。一般的做法就是加一个硬的约束，如果准确地预测到障碍物的位置，那么在不会碰到障碍物的地方，加一个BoundingBox,让机器人通过这个点的时候，一定在处在这个BoundingBox里。

对于前一种方式呢，经常会使用软约束。通过软约束的形式把推力施加到轨迹上。

而后一种方式呢，则是硬约束，让轨迹生成的时候呢，一定要通过约束住的这些区域。

![image-20211003120719474](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003120719474.png)

**硬约束和软约束的定义：**

一个优化问题，是有一个目标函数和约束条件的。

**而对于硬约束而言，不管是等式约束还是不等式约束，一定要求是全局都满足的，严格满足数学表达式，才是硬约束。**

**软约束：就是把s.t.,加到了目标函数里，没法保证约束一定成立，使得约束倾向于实现，而不是一定实现。**

![image-20211003124920279](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003124920279.png)



## 6.2 硬约束优化

**硬约束的规划优化，就是在环境中可通行区域，移动机器人的轨迹一定要从这里走的一种约束。**现在被广泛使用的一种方法呢就是基于走廊的轨迹优化方法。

![image-20211003130436591](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003130436591.png)

第一步，把检测到的障碍物塞入八叉树地图（和栅格地图不同，格子是有大有小的，没有障碍物的地方一大片都是一个节点，有障碍物的地方，会一直切分）。

第二步，前端图搜索的方法，找出一条可行路径。实际上就已经构成了一条飞行走廊，Path本身是有一定的体积的。

第三步：将飞行走廊在八叉树地图里做一个膨胀，把路径里的每一个格子都进行膨胀（不碰到障碍物即可），并且去除掉里面重复的部分，最后会得到一个飞行走廊。

第四步：最后就是在膨胀过后的飞行走廊里生成多项式表示的轨迹。

![image-20211003130542306](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003130542306.png)

Transition Point 两段轨迹的连接点:一定在两个方块的重叠区域。但是没法保证一段轨迹的中间所有点一定在一个方块内。

![image-20211003133208313](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003133208313.png)

这种基于走廊的轨迹优化方法呢，有很多好处。第一个是：在八叉树的地图里，做路径搜索和轨迹优化时，都非常有效率。

第二：飞行走廊：提供了非常大的解空间，可以一直优化到最优解。还有一个优点就是，就是有一个隐形的时间分配，因为中间的点是可以自由移动的。

![image-20211003133938929](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003133938929.png)

缺点：如何去施加Interval的约束？

解决方法：先生成一个轨迹，例如$y_b$是边界条件,生成轨迹之后，去进行一个检查，不需要检查全部，只需要迭代的检查极值，一直到把整段轨迹都压下去为止。如果整段轨迹都在飞行走廊里了，那就结束了。

![image-20211003134755829](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003134755829.png)

因为检查极值就涉及到多项式求根的问题，对于四次及以下的求根问题，都是直接代公式就可以了。

如果是对更高阶的话，就用伴随矩阵的方法，参考MATLAB是怎么做的。伴随矩阵A的特征值，就是多项式的根。

![image-20211003141500262](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003141500262.png)

**另一种方式：用贝塞尔曲线来生成Minimum Snap轨迹。**

![image-20211003141955130](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003141955130.png)

使用Bernstein这种特殊的多项式去替换我们常见的多项式的基底。它的基底是$b_n^i(t)=C_n^i.t^i.(1-t)^{n-i}$。n代表多项式的阶数。这里的系数C，叫做控制点。这里的控制不只是一个系数，是有物理含义的。Bernstein多项式组成的函数呢，就叫Bezier曲线。

总是可以找到普通多项式与Bezier曲线的映射关系的。

![image-20211003143241364](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003143241364.png)

**贝塞尔曲线具有的普通多项式达不到的特点：**

1.一段贝塞尔曲线总是起始于第一个控制点，终止于最后一个控制点，一定不经过中间的其他控制点。

2.凸包Convex hull性质：一段贝塞尔曲线一定被它所有的控制点所定义而成的凸包所完全地包围住。

3.一段贝塞尔曲线求导以后仍然是贝塞尔曲线Hodograph，它的所有的控制点是可以用本身的控制点，写成一个线性的表达式。

4.固定时间间隔。每一段贝塞尔曲线一定是定义在[0,1],这一点相对不那么灵活。

![image-20211003152221668](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003152221668.png)

如何使用凸包的性质？

1.我们前面的飞行走廊是由一个一个方块Cube组成的，每一个cube本身一定是凸的，**如果把某一段贝塞尔曲线都限制在它对应的凸包里，每一段凸包又在飞行走廊的cube里，那么总体轨迹就被完全限制在了飞行走廊里。**

只需要控制点个数的约束条件，就可以了。

![image-20211003153628995](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003153628995.png)

仍然是一个典型的QP问题。

![image-20211003155329881](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003155329881.png)

给Minimum Snap加上硬约束的其他选项：Dense constraints加很多很多约束。

问题：结果非常保守

优点：要求解的系数少；有比较好的理论上的保证。

![image-20211003160334054](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003160334054.png)

另外一种：混合整数优化。大M法。

求解这个问题：MIQP问题，这个问题求解会非常慢，很难在线求解。对于单个无人机在复杂环境中避障，没必要用这个方法。

这个文章提出来是用在多无人机编队互相避障的一个方法。

![image-20211003162021844](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003162021844.png)

## 6.3 软约束优化

软约束一般来说是用障碍物产生一个力，使得机器人运动轨迹远离障碍物。一般用距离来描述这个力。

![image-20211003163212910](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003163212910.png)

为什么要用软约束的方法？因为硬约束的方法把环境分成两部分，有时会使得轨迹离障碍物的距离不够Low clearance。在实际过程中，由于控制的误差，在这个部分可能会有碰撞的危险。

软约束的方式：如果目标函数设计的不好，那么碰上障碍物是可能的。

![image-20211003163329371](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003163329371.png)

目标函数：光滑项+碰撞惩罚项+动力学项

碰撞项：把轨迹上的每一个点，根据离障碍物的距离，在距离场上的惩罚，做一个累积。这里是对曲线进行积分，

![image-20211003165227244](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003165227244.png)

目标函数写出来之后，接下来就是怎么优化？因为不是一个凸优化问题，只能用非线性优化的方法。

首先要把目标函数的导数求出来。下面的步骤就是求$J_s和J_c$的导数。

![image-20211003170005229](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211003170005229.png)

ESDF:表示了环境里每一个点到障碍物的距离，颜色越红，表示离障碍物越近。对于越近的地方，要给它一个越大的惩罚。可以用指数函数来作为惩罚函数。

![image-20211005091754058](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005091754058.png)

**Cost Function写出来了，导数求出来了，具体怎么做数值优化呢？**

实际上就是要找一个x的序列，使得f(x)值渐渐地逼近全局最优解，或者说，使得f(x)的导数渐渐逼近于0

![image-20211005091946849](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005091946849.png)

梯度下降方法：就是要估计一个f(x)下降的方向，在每一步迭代过之后，使得$f(x^{k+1}<f(x^k))$。

停止条件：往左或往右都无法再下降了。

缺点：显然这种方法不是全局最优的，而且是对初值敏感的。

![image-20211005092728327](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005092728327.png)

**这种方法实际上就分为两步。一个找下降的方向；另一个是找步长。（比如说你走一步，不一定能保证f(x)下降）**

**Line search就是为了找合适的步长。**在t取一个步长时，使得f(x)得到最大的减小。

但是实施的方法是：先走一个初始步长，再二分查找，找一个合适的步长。（如果太大，就取一半）

![image-20211005092842415](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005092842415.png)

具体操作的时候，无约束的非线性优化方法，又分为一阶方法和二阶方法。

**一阶方法：梯度下降方法。往导数的负方向去走**。停止条件：前后几次函数变化值很小。（同数值分析课上满足一定精度值就停下）

![image-20211005094109487](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005094109487.png)

**二阶方法：牛顿法以及牛顿法的衍生法。**

前进方向：不光是用梯度来判断了，而是用$-\frac{J(x)}{H(x)}$，H(x)二阶导数,J(x)一阶导数。

高斯牛顿法：对H(x)做近似，用$J^T_fJ_f$近似H(x)

![image-20211005094310842](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005094310842.png)

L-M方法：实际上是一阶方法和二阶方法的折中。如果$\lambda$等于0，就是高斯牛顿法（二阶法），如果$\lambda$很大，那前面的项可以忽略不计，就是负梯度方向（一阶法）。$\lambda$是动态调整的。

**关于这种问题的非线性优化方法，都有现成的软件库可以用的,不用自己写。比如Ceres，NLopt。一般做Slam的用Ceres很多，做planning的用NLopt用的多。**

真正用的时候，只需把目标函数及梯度写出来即可。

![image-20211005094512426](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005094512426.png)

**==接下来回顾整个planning work的框架，以及怎样部署在无人机上。==**

首先整个过程分为前端后端，前端：找到一条全局path；首先由于无人机的感知距离是有限的，所以只会在很短的距离内做一个planning。每次需要在前端上找一条局部的Path，然后在后端进行局部的轨迹生成。

由于高频的重规划，有可能导致，我们轨迹还没执行，就产生下一条新轨迹，这样会导致无人机，左右摇摆，导致它前后一致性很差，**因此我们往往会在生成的轨迹上固定一段，把它执行完了，再做下一次的规划。**

第二个是探索策略：因为环境里有时是没有路的，不是因为真的没有路，而是因为传感器的噪声，把前面的路挡住了，这时候让无人机在原处，或周围小范围内，进行一个左右的探索，让他把路看清楚。

![image-20211005095904611](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005095904611.png)

软约束的优化方式的初值选取问题：一是可以用前端找出来的直线Path，这种轨迹不光滑，但是一定是安全的，一般都用这种方法，把指数函数作为碰撞项。

二是用minimum snap 的轨迹作为初始值。这种方法可能不安全。

![image-20211005101005318](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005101005318.png)

优化策略：两步走。第一步：先不管光滑项等，只考虑$J_c$去做优化。尽可能地把轨迹往远离障碍物的地方去推。之后，在相对于障碍物比较远的位置，再把前两项加回来做优化。

![image-20211005101731274](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005101731274.png)

## 6.4  案例学习Fast-Planner

![image-20211005103851870](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005103851870.png)

后端：基于软约束的轨迹优化

![image-20211005103947138](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005103947138.png)

梯度下降法优化后端的缺点：

![image-20211005104101554](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005104101554.png)

**为了解决上述问题：使用B-Spline来代替传统的普通多项式轨迹。贝塞尔曲线的性质B样条全都具备。**

**均匀B样条：直接把推力施加到控制点上，使得整个凸包远离障碍物，并使得计算速度变得很快。**

![image-20211005104131944](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005104131944.png)

表示轨迹光滑的函数：elastic band.

这里碰撞项：用的是二次函数，是为了使计算变得快。

![image-20211005110949309](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005110949309.png)

## 6.5 Homework

作业：基于走廊的硬约束轨迹优化。

![image-20211005111245678](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211005111245678.png)

![image-20211014113227717](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014113227717.png)

### ==轨迹怎么用？（轨迹跟踪）==

至此，我们已经求得了轨迹（很多段高阶多项式的参数），但怎么用来控制机器人运动呢？轨迹跟踪是：根据轨迹和机器人当前状态（当前位置、速度、加速度），输出机器人控制指令（速度、加速度、角速度等），控制机器人沿着轨迹运动。有很多种跟踪方法。

![image-20211013210436268](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211013210436268.png)

### 小结

- 轨迹规划问题通常建模成一个带约束的二次规划（QP）问题来求解，优化函数可以是snap、jerk、acceleration及它们的组合或其他任何能够formulate成$p^TQp$形式的函数，约束包括等式约束和不等式约束。
- 轨迹规划中默认时间t已知，通常根据期望速度和总路程计算一个总时间T，再按照匀速运动和梯形速度曲线分配到每段polynomial上。

- 上面例子中规划出的轨迹并不是很好，有以下问题：
  - a) 轨迹与路径相差有点大，而且在第三个waypoint处会有打结的现象；
  - b) y轴的加速度非常大（接近20 $m/s^2$），超过了机器人的最大加速度。实际轨迹需要进行feasibility check（可行性检测），确保满足工程可行性，比如最大速度、最大角速度限制等。
- 这两个问题的根本原因在于时间给的不合理，**时间分配是轨迹规划中比较麻烦的问题，给的时间太小，速度、加速度自然就很大，两段时间分配不当就会生成打结的轨迹。下一节，专门讨论时间分配问题。**

# 7.基于马尔科夫决策过程的运动规划

第7章学习记录博客：https://blog.csdn.net/weixin_44558122/article/details/118530985

![image-20211014145634643](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014145634643.png)

不同于传统的路径规划，这里的planning指得是有很多决策树。

## 7.1 规划中的不确定性

不确定性在现实中是普遍存在的。包括执行上的和状态估计上的。

![image-20211006103150752](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006103150752.png)

![image-20211014152850579](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014152850579.png)

从数学上来描述，不确定性可分为两类。

1.Nondeterministic:机器人完全不知道自己的动作会受什么样的干扰。

2.Probabilistic:机器人可以通过经验、观察等，能够大体知道自己受到干扰之后的程度。

![image-20211006103343307](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006103343307.png)

**在之前的规划当中，只具有robot一个主体。但是在Planning With Uncertainties中，规划及执行是由Robot、Nature两者相互作用的结果。**

![image-20211006103647121](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006103647121.png)

![image-20211014152950427](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014152950427.png)

Game的两种分类：Independent Game & Dependent Game

![image-20211014153216401](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153216401.png)

nonempty set:非空集合。

![image-20211014153325318](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153325318.png)

![image-20211006132433033](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006132433033.png)

![image-20211014153342875](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153342875.png)

![image-20211006132533375](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006132533375.png)

两种不同的解法: Worst-Case-Analysis, Expected-Case-Analysis。

一步法：有理由认为，Nature永远采取最不利的行为。

![image-20211014153525632](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153525632.png)

![image-20211006132615162](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006132615162.png)

另外一种一步法：在Probabilistic模型下，Nature要做什么动作，大致是知道的。

![image-20211014153558626](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153558626.png)

![image-20211014153725146](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153725146.png)

![image-20211006132635314](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211006132635314.png)

Nature施加的影响(Nature的动作)不一样，导致机器人的动作也受影响，不一样。

![image-20211014153919667](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014153919667.png)



![image-20211008105302798](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008105302798.png)



多步法：机器人可以不止走一步，可以走多步。这里有一个状态转移函数。分为离散的和连续情况下的。分别是$X_{k+1}$,$P(x_{k+1}|x_k,u_k)$。

![image-20211014154034634](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154034634.png)

![image-20211014154125270](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154125270.png)

![image-20211008105531029](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008105531029.png)

![image-20211014154239326](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154239326.png)

![image-20211008112110454](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008112110454.png)

## 7.2 马尔科夫决策过程

![image-20211014154418828](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154418828.png)

![image-20211008112151212](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008112151212.png)

![image-20211014154852003](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154852003.png)

![image-20211008112349363](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008112349363.png)

![image-20211014154922590](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014154922590.png)

**MDP做规划的相关定义**

![image-20211014155043945](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155043945.png)

![image-20211014155149506](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155149506.png)

![image-20211014155211584](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155211584.png)

## 7.3 最小最大代价规划和最小期望代价规划

**极大/极小代价函数的规划(Minimax Cost Planning)**

![image-20211014155231942](/home/cl/.config/Typora/typora-user-images/image-20211014155231942.png)

**递归关系寻找过程**

![image-20211014155908565](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155908565.png)

![image-20211014155929669](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155929669.png)

 **算法1:Nondeterministic Dijkstra**

![image-20211014160016694](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160016694.png)

![image-20211014160041260](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160041260.png)

![image-20211014160309917](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160309917.png)

![image-20211014160635200](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160635200.png)

![image-20211014160651354](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160651354.png)

**算法优缺点**

![image-20211014160718840](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160718840.png)

## 7.4 期望价函数的规划和值迭代

**7.4.1 相关描述**

![image-20211014160405362](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160405362.png)

**7.4.2 递归关系寻找过程**

![image-20211014160547229](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160547229.png)

![image-20211014160603669](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014160603669.png)

**算法2: Value Iteration**

![image-20211014155500821](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155500821.png)

![image-20211014155517380](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155517380.png)

**算法优缺点:**

![image-20211014155555090](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155555090.png)

## **7.5 实时动态规划(Real Time Dynamic Programming)**

![image-20211014155624750](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155624750.png)

![image-20211014155759873](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155759873.png)

![image-20211014155817218](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211014155817218.png)

## 7.5 Homework





# 8.模型预测控制在运动规划的应用

## 8.1 总体介绍

什么叫模型预测控制？它和Motion Planning有一些什么样的关系？

分别从模型、预测、控制来介绍。

什么是模型？对于质点而言，知道了质量和加速度，就可以完整的描述这个质点未来的轨迹。这也就是System model。

Problem model：就是红点表示的$min(p-p_d)$。

预测：给定输入之后，状态(p,v,a)会怎么变化。参数空间：因为现实世界是连续的，例如未来三秒内，力的变化是有无限多种的，这样的话，连续的优化问题是很难解的。我们需要把力的变化放到一个参数空间里面去表达，比如用有限阶的多项式来描述，那么在优化的时候只需优化多项式的参数即可。

控制：在参数空间里面选取最好的参数。或者说最好解的过程。





![image-20211008112623054](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008112623054.png)

目标函数：属于问题模型，

第一项：动力学约束

第二项：不等式条件；比如最大速度、加速度限制。

第三项：等式条件：比如飞机的当前状态，它想终止于另一个状态，比如边界约束，都归到等式条件里面。

第四项：碰撞避免约束。往往需要对这一项进行特殊处理。

![image-20211008163607262](/home/cl/.config/Typora/typora-user-images/image-20211008163607262.png)

关于参数空间的重要性：它在预测轨迹的时候是一个非常重要的工具。

Zero order hold：是把系统输入，按照一定的频率，来进来直接的离散。给定一个采样频率，和一个固定的时间段，就能得到离散出来的输入信号。

Polynomial和B-spline：通过调整多项式系数，使得输入u能够最小化目标函数。

最后：非线性的方式建立参数空间。比如神经网络，目的都是进一步的减小参数空间的维度，使得优化问题更容易解。

![image-20211008165149860](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008165149860.png)

参数空间一旦建立好后，我们就要考虑如何去找这些最优参数，也就是优化问题本身。这里常用的方法如下：

对于一些非凸问题，不得不使用一些工具：SQP，Particle swarm optimization最大的好处是不仅可以解决非凸问题，更可以解决非连续的问题。

![image-20211008170309167](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008170309167.png)

整个模型预测控制的框图如下：依据信号流的顺序来进行解释。

![image-20211008171052610](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008171052610.png)

传统的MPC问题在于，如果系统要求控制频率非常高，才可以正定的住，比如说四旋翼的内环，要求200-1000hz的控制频率，这就要求优化问题在非常端的时间内得到求解，但这对于四旋翼的机载计算资源来说是不现实的。

为了解决这个问题：人们发明了Tube based MPC。在这个框架里面，多了两部分内容，Nominal System和Associate controller。

这个系统的优势在于，可以以极低的频率来解优化问题，从而节省计算量。

![image-20211008172009781](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008172009781.png)

## 8.2 线性MPC

线性MPC解决的优化问题通常是凸的。而非线性MPC解决的优化问题通常是非凸的。大部分工程问题，特别是运动规划问题中，都需要使用到非线性MPC。不管是线性MPC还是非线性MPC，它们的核心都是解优化问题。

以4s的时间为例，这个4s叫做prediction horizion。

![image-20211008172940282](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008172940282.png)

**把离散化的模型变成矩阵表达形式，把这种矩阵表达形式叫做预测模型，也是MPC的第一步。**每当我们选定参数空间中的一组参数之后，我们就可以通过预测模型来得到系统状态在未来的值。（P,V,A）

![image-20211008184128540](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008184128540.png)

在有了预测模型之后，**MPC的第二步，就是建立问题模型**。**问题模型可以被写作待优化的目标函数**。

这里的例子：

**目标1：把三阶积分器带回到状态空间中的原点。**

**目标2：在目标1中，轨迹尽可能的平滑。**

对于第一个目标：通过减小$P^2+V^2+A^2$来达到，对于第二目标，通过减小输入的幅值来达到，也就是最小化jerk。

![image-20211008185024509](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008185024509.png)

在**问题模型建立好之后，就是使用优化算子来解答这个优化问题（MPC的第三步）**。以预测模型的形式代入目标函数。之后不难看出这是一个二次优化问题。这个二次优化问题的Hexian矩阵（中间部分），是正定的，那么可以肯定这是一个凸优化问题。

![image-20211008190236778](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008190236778.png)

在解开了这个优化问题之后，**MPC的第四步，是用得到的最优控制信号去驱动实际系统**。

![image-20211008190631661](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008190631661.png)

如何加入速度和加速度的约束？把不等式改写成矩阵的形式。然后代入之前的预测模型，得到了四组约束条件。

![image-20211008192733664](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008192733664.png)

大部分MPC问题，都愿意把目标放在优化函数里面，而不是作为约束条件，这样的话优化问题是能保证有解的。这就是硬约束

![image-20211008193356392](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008193356392.png)

在下面的情况下，硬约束可能导致优化问题没法产生解，但软约束就可以使得优化算子依旧给一个最接近的解出来。

![image-20211008193621476](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008193621476.png)

软约束的基本思想：把约束条件变成惩罚项放到优化目标里面去，比如下面对V的惩罚函数。

![image-20211008195242537](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008195242537.png)

依旧可以使用二次规划的算子来解决软约束问题。添加一个slack变量L。

![image-20211008200048807](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008200048807.png)

使用软约束的结果：左图是没有违反约束（v要在正负1内）时的结果，其与硬约束的结果应是一样的。当违反约束时，软约束的MPC会先把违反约束的状态带到约束之内，然后再把三阶积分器的全部状态带到状态空间的原点。

![image-20211008200312392](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008200312392.png)

然后讲一下在设计MPC的时候，哪些约束条件考虑成软约束，哪些约束条件要考虑成硬约束？

一般地，所有的状态都考虑成软约束。这是因为状态往往会受到测量噪声和外界干扰的影响，使得初始值一来就违反了约束，使得优化问题没有解；输入的话，因为不会受到干扰，一般都考虑成硬约束，而且因为输入超过了它的范围的话，容易对机械系统带来损伤。

![image-20211008200554479](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008200554479.png)

线性MPC的缺陷：1.要求你的系统模型是线性的。2.它的障碍物的处理不是特别好。当涉及到“或”这个操作的时候，问题就变成了非凸的。

![image-20211008201854074](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008201854074.png)

BSCP参数空间：起始状态，期望状态。

![image-20211008203011561](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008203011561.png)

参数空间：JLT。不只是加加速度受限制，加速度和速度也受限制。加速度对应的是力，而加加速度受到限制的话，证明这个力是连续的，没有跳变。

![image-20211008203113086](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008203113086.png)

四旋翼模型和JLT的关系：

机体倾斜的速度限制$w_{max}$：电机升力限制$f_{max}$：,但是在做运动规划的时候，是对pva做规划，并不是直接在$w_{max}$和$f_{max}$上进行规划，所以要把内环限制映射到外环上。外环第一项约束了加加速度，二和三约束了加速度。但是这三个公式依旧非常复杂，而且不是线性的。最后得到的就是JLT轨迹的约束条件。

![image-20211008203625444](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211008203625444.png)

这里的$u_j$是加加速度输入。

![image-20211009090709896](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009090709896.png)

接下来重点讲讲JLT。因为JLT的用途比较广泛。这里先讲二阶积分器，（从加加速度积分到速度）。它的末端速度是可以随意变化的，末端加速度必须是0.

这里加加速度是三段，要么是最大，要么是最小，要么是0.

![image-20211009090952048](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009090952048.png)

根据上面的说法，我们的目标，就是使得加速度阴影下面的面积等于速度的变化。当速度变化比较小的时候，就是要一个较小的三角形，当需要一个小一点的三角形的时候，速度是达不到最大值的。当得到的所需加加速度的三段各自维持的时间之后，就可以求解出加速度和速度的轨迹了。

![image-20211009092257508](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009092257508.png)

**那么接下来看这个三阶积分器。**它的末端位置是可以随意设定的，末端速度、加速度必须是0.

![image-20211009094023666](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009094023666.png)

使得速度曲线下面覆盖的阴影面积刚好等于我们想要的位置变化。

![image-20211009094145647](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009094145647.png)

JLT方法的应用：解决安全走廊的问题。

![image-20211009100248640](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009100248640.png)

JLT方法可以用在很小的飞机上，可以直接在Pixhawk里面跑。对突发情况能很快做出反应。

![image-20211009094746852](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009094746852.png)

## 8.3 非线性MPC

JLT第一步：环境观测：建立地图的过程。

EDT：每一个点到它最近障碍物的距离。

![image-20211009102059595](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009102059595.png)



第一步：全局路径规划

第二步：轨迹规划；在折线段上找一个拐点，让飞机时刻朝拐点飞行，一旦飞机离拐点较近后，就朝下一个拐点飞行。

第三步：JLT一旦确定了初始状态和目标状态之后，每次选定一个$x_f$就可以得到一条轨迹。目标就是要找到一个cost最小的轨迹。

![image-20211009105333435](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009105333435.png)

打分Evaluator：

很多打分的方式是直接在轨迹上采点，但是这样有问题，有可能障碍物出现在两个点之间，这样的话会直接跳过障碍物了，这样是不好的。

解决方法：点之间通过射束连起来，这个射束会经过格子图里面的所有格子，然后检查格子有没有出现障碍物，如果出现了障碍物这条轨迹就是不安全的。

![image-20211009111542758](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009111542758.png)

MPC的过程是每隔一段时间$\Delta t$要重新优化一次的,那有没有更加聪明一点的方式呢？答案是肯定的。那就是事件驱动的MPC，只有当事件发生的时候，我们才重新优化。没有事件发生，则沿用上一次的轨迹。往往搭配Tube-based MPC来使用。

![image-20211009111943301](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009111943301.png)



软约束：惩罚函数。

找到一个$x_f$，使得打分最低。

![image-20211009113015839](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009113015839.png)



![image-20211009113508827](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009113508827.png)

粒子群优化PSO，采样很多次$\theta$点。不需要梯度。



JLT也不是万能的，只能用在三阶积分器的模型上。



用神经网络求解，比求解多次BVP问题快得多。

![image-20211009145949005](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009145949005.png)

## 8.4 Homework

跟踪螺旋线，三阶积分器

![image-20211009153602369](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009153602369.png)

![image-20211009153614041](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211009153614041.png)

# 9.实践Project