# 1.概述和课程介绍

（1） 研究内容：移动机器人的运动规划。这门课的主讲老师，就是文章（TGK-planner）的通讯作者。课程内容与文章内容有很高的相关性。

![image-20210913085423461](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085423461.png)

（2） 学习路线

![image-20210913085409570](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085409570.png)

前端路径发现（搜索）：在一个相对低维的通常是离散的状态空间中，让机器人搜索一个初始的（解的质量不是特别好的）path,没有高维的信息。

后端的轨迹优化（生成）：在高维的连续空间中执行的（寻找一个可执行的轨迹），要用到很多的优化技巧。

**前端：Path finding**

**1) 基于搜索的Path finding**

A) 图的基本概念：机器人为了在环境中进行导航，会用到很多种类型的地图。

B) Dijkstra and A*算法

C) Jump Point Search(跳点算法，实际上是A*的改良版本)

**2) 基于采样的Path finding**

A) Probabilistic Road Map概率路线图:经典的随机采样的路径规划方法

B) Rapidly-exploring Random Tree随机扩展快速采样的随机树算法（RRT）

C) Optimal Sampling-based Methods  具有渐进最优性的改良版本,称为RRT*

**3) Kinodynamic Path finding(满足动力学要求的轨迹规划，开始考虑动力学模型)**

A) State-State Boundary Value Optimal Control Problem满足两点边界值的最优控制问题

B) State Lattice Search状态图的搜索（其实是高维的Dijkstra或A*）

C) Kinodynamic RRT 引入动力学的RRT

![image-20210913085519021](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085519021.png)

**D) Hybrid A* 混合A*算法**

**后端：Trajectory Generation**

1) Minimum Snap 轨迹生成,再交给移动机器人执行

![image-20210913085553057](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085553057.png)

**2）Soft and Hard Constrained Trajectory Optimization**

A) 软约束轨迹优化

B) 硬约束轨迹优化



**常用地图结构**

1.占用栅格地图

**![image-20210921104259435](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104259435.png)**

- 最稠密--每隔一个距离就要进行切分（当每个格子切的比较小也就是分辨率比较大的时候，内存非常大）

- 结构化

- **坐标索引查询，O(1)**

  **2、Octo-map 八叉树地图**

  环境中没有障碍物的地方，就用大的方块表示，当大方块里面有小部分有障碍物，就递归地切分下去，直到包含了障碍物为止。

  - 稀疏的

  - 结构化

  - 非直接索引查询

    ![image-20210921104440591](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104440591.png)

**3、Voxel hashing 体素哈希**

通过二重哈希表来存储障碍物边界的每个voxel（单元栅格）

![image-20210921104552046](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104552046.png)

**4、Point cloud map 点云地图**

- 无序

- 无索引查询

  ![image-20210921104626501](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104626501.png)

**5、TSDF map (Truncated Signed Distance Functions) 截断的有符号距离函数**

距离值：曲面外部为正值，内部为负值，并且可以以距离的大小来进行截断，比如正负两米内的点保留。

![image-20210921104758485](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921104758485.png)

**6、ESDF map（Euclidean Signed Distance Functions）欧式有符号距离函数**

TSDF不截断的话，就是ESDF

当进行轨迹规划时，需要知道机器人距离障碍物的梯度，所以不需要进行截断。

![image-20210921105253062](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105253062.png)

**7、其他**

[Free-space Roadmap](https://link.zhihu.com/?target=https%3A//github.com/HKUST-Aerial-Robotics/Teach-Repeat-Replan)：随机采样的概率路线图，用**凸多面体**来表示路径点，再连接起来

![image-20210921105343506](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105343506.png)

[Voronoi Diagram Map](https://link.zhihu.com/?target=https%3A//github.com/ethz-asl/mav_voxblox_planning)：利用ESDF提取地图的骨架--拓扑结构，稀疏

![image-20210921105354578](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921105354578.png)

# 2.基于搜索的路径规划

1）机器人规划的配置空间：

Configuration Space:对机器人上所有点的位置的描述。在配置空间中做规划：将工作空间中的planning变成配置空间中的planning。

在配置空间中要注意对障碍物的处理：C-obstacle；对障碍物和机器人的体积做膨胀。 处理过后，运动规划就是在C-free空间中找到一条从开始点到目标点的路径。

![image-20210913085606665](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085606665.png)

![image-20210913085611242](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085611242.png)

2）图搜索算法的总体框架：

A) 总是要维护一个容器：这个容器装载着全部将来要去访问的节点。

B) 这个容器一开始是空的，最先放入的是起始点。

C) 最后进入一个循环。各种搜索算法其实都可以归结在这个循环框架里 

循环分为三步：

1）弹出一个节点（根据一项指标、一种目的）Remove

2）扩展这个节点所有的邻居Expansion

3）对于所有扩展出来邻居节点，再重新装入容器中。Push

循环持续到：容器中没有任何节点可以被弹出为止。

![image-20210913085624694](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085624694.png)

图的遍历：

![image-20210913085643266](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085643266.png)

DFS弹出容器中最深的节点，在每次扩展时把每个可能的分支走到底。

BFS弹出容器中最浅的节点，所以BFS是分层遍历的。

贪心算法：每次都选择局部最优。

用BFS搜索的前提是图中每条边的权重是相同的，比如都是1.

Dijkstra算法：弹出的节点n需具有最小的cost: g(n):从起点到n节点的代价总和最小。如果所有边的权重都是1的话，Dijkstra算法等同于BFS。

![image-20210913085703625](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085703625.png)

**A\*算法：Dijkstra算法Cost g(n) + 启发式h(n)**

![image-20210913085710286](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085710286.png)

![image-20210913085737357](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085737357.png)

![image-20210913085743251](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085743251.png)

**==几种方式的区别：贪婪、加权A$*$ 、A$*$、Dijkstra==**

![image-20210923194256819](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923194256819.png)

**Jump Point Search跳点搜索：打破对称性**

![image-20210913085754127](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085754127.png)

Look Ahead Rule: (Straight pruning rule)如果一个节点可以通过x的父亲到达（在cost小于等于的前提下），那就没有必要通过x到达。(跳点，打破对称性）

![image-20210913085805964](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085805964.png)

上方左图红色箭头代表父节点的来源。（分为直线来源和对角线来源）

当出现障碍物邻居的时候，就会出现Forced Neighbors.

优先考虑水平和垂直方向的跳跃。

 

![image-20210913085831401](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085831401.png)

优先考虑水平和垂直方向的跳跃。（地图边界等同于障碍物处理，在右三图中，水平和垂直方向的跳跃都会失败，因为都会碰到障碍物）于是进行对角线跳跃，到y节点。y节点是一个关键节点。

将Forced neighbors(expanded)加入优先级队列中(push),将父节点x弹出(Remove).

![image-20210913085853615](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085853615.png)

不会有折线跳跃，每一次的跳跃一定是直线的。

![image-20210913085901597](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085901597.png)

A*的代码与JPS的代码几乎一致，唯一的区别在于怎么去找n节点未扩展的邻居。

A*的邻居找的是几何上能达到的邻居（除去障碍物的邻居节点）。但JPS找的邻居是根据跳点规则和look Ahead规则找到的跳点邻居。 A*在扩展几何上紧密连接的邻居，而JPS在地图上空阔区域进行大范围的跳跃。 

![image-20210913085917844](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085917844.png)

![image-20210913085932408](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085932408.png)

**在大多数情况下，尤其是复杂环境中，JPS比A*更快**。因为它减少了优先级队列中扩展的节点数量，在队列中对节点进行的操作次数也会变少，从而节省计算量；但是它增加了环境中碰撞查询（collision query）的次数,积少成多也会是一笔计算开销。

![image-20210913085942012](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085942012.png)

JPS的限制：只适用于规则的栅格地图。

![image-20210913085952057](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913085952057.png)

**==基于搜索的路径规划方法建立在地图的基础之上，通过对图的搜索，规划出从点A到点B的最优路径。==**

基于采样的路径规划：不需要遍历从点A到点B的所有网格，而是通过在空间中随机洒点，通过一些线段把这些点连接起来的方式，构建一颗树（图），来表示空间。尤其适用于复杂空间，适用于三维或更高维的情况。

**3、** **结论**

（1） 目前学完了前两章，了解了总体框架和学习路线，学习了基于搜索的和基于采样的路径规划方法，实践了A*和JPS算法。因为课程的作业要求ROS下的c++实现，所以对于理解开源代码也有好处。

![image-20210913090035996](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913090035996.png)

（2） 下一步工作思路及计划：后续重点关注RRT*算法和kino RRT*算法，并进行编程实践。基本上学完前6章，应该能把动力学规划这一块弄懂了。

![image-20210913090044129](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210913090044129.png)

***\*Motion planning当前的研究难点：\****

kinodynamic path searching。纯geometric path search的planning前端已经是几年前的事情了，要让无人机飞行动态性能好（速度快，运动smooth，节省能量），现在普遍需要的是on the flight的onboard kinodynamic path finding，之后再接上后端的轨迹优化。kinodynamic path searching解空间维度高，问题复杂度大，引申出来的问题包括：如何快速求解two point bounda value problem, 如何针对你的系统设计高效的heuristic，如何保证每次replan前后的motion consistency。最简单的测试指标，复杂环境里，你能让无人机飞多快？环境越复杂，飞的越快，就越NB。

**---转自 高飞**

![image-20210921093624071](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921093624071.png)

栅格地图：对环境进行方格化、离散化的栅格地图，维护一个栅格地图需要很大的内存空间。

欧氏距离场：欧氏距离场首先需要一个栅格地图，此外欧氏距离场记录了栅格地图里每一个点到最近的障碍物点的距离和方向，所以可以进行梯度计算，因此非常适合于无人机的局部避障，因为可以判断每个障碍物点对。

八叉树地图：改善了栅格地图占内存很大的缺点。

**==飞行走廊：因为障碍物是不规则的，所以用凸多面体把环境里的free-space抠出来，反正障碍物不会在飞行走廊里，接下来飞行器只需要在飞行走廊里运动就可以==**

用飞行走廊这样一种几何空间的约束去表述环境中的可行空间之后，我们就可以去求解一个，把椭球状的无人机叠加一个model，约束在飞行走廊里的一个后端优化问题。

# 3.基于采样的路径规划

采样：在空间中撒一些点，然后用线段把这些点连起来，形成图。 然后这个图代表了简化的地图。从而在这个图结构上找从start点到Goal点的方式。

优点：更加高效，尤其适用于复杂空间及三维或更高维的环境。

Completeness in planning 规划的完备性。

比如A*算法就具备这样的完备性

**概率完备性：如果有这样一条路径存在，那么通过采样的方式，一定能把这条路径找出来。**

![image-20210923193040575](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923193040575.png)



![image-20210921111652729](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921111652729.png)

## 3.1 概率路图PRM

![image-20210921111801438](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210921111801438.png)

PRM是一种图结构，分为两个阶段：学习阶段和查询阶段。

**学习阶段**：我们希望对冗长的地图做一个简化，如何简化：就是通过对图的学习，从而找出一个简化地图。

具体方式：

1.在环境中均匀地撒一些点（也有偏置式、启发式的撒点）；

2.删除在障碍物区域内的点；

3.（可以根据一定的规则）连接近邻的几个点；

4.删除和环境碰撞的路径段（或过长的线段）。

**查询阶段：就用A*或Dijkstra算法**

![image-20210923193955644](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923193955644.png)

优点：概率完备、简化了图之后，相对于A*或Dijkstra算法而言是高效的。

缺点：

1.现在用直线来连接2个点，但是对于机器人而言，有些轨迹是不适合运动的，不是最优效率。

2.不够高效，没有把找一条路径放在心上。

不够高效的第一个原因：

1.检测点或线段是否在障碍物中，是很耗时的。

解决办法：先不管线段是否碰撞了障碍物，lazy collsion-checking.

![image-20210923200752190](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923200752190.png)

![image-20210923202057845](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923202057845.png)

找到一条路径之后，再对这条路径进行Collsion-checking，然后删掉碰撞的点和边，然后重新开始寻找路径。



## 3.2 快速搜索随机树Rapidly-exploring Random Tree

相比于PRM更有针对性，能够快速地在空间中规划一条路径，在高维空间里更快。

树是增量式构建的，不需要区分learning phase和query phase,它的目标就是构造一条路径。也不需要利用Dijkstra和A*算法，只要终点被加入到路径中，就进行反方向查询，就可以找到可行路径。

![image-20210924104628078](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924104628078.png)

![image-20210924105310925](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924105310925.png)

RRT优点：1.目标是找到一条从起点到终点的路径；2.相对PRM更以目标为导向。

缺点：1.并不是最优路径；2.相对来说，也没有那么高效；

**改进方法：提高效率**

Kd-tree：把一些点用做空间的划分，这些点并不是一维的。改进思路就是修改Nearest()函数。使得$X_{rand}$能够更快的找到$X_{near}$

![image-20210924105757867](/home/cl/.config/Typora/typora-user-images/image-20210924105757867.png)

**怎样构造一棵Kd-tree？**

对于Kd-tree这样一棵二叉树，我们首先需要确定怎样划分左子树和右子树，即一个K维数据是依据什么被划分到左子树或右子树的。

在构造1维BST(二分搜索树)树时，一个1维数据根据其与树的根结点和中间结点进行大小比较的结果来决定是划分到左子树还是右子树，同理，我们也可以按照这样的方式，将一个K维数据与Kd-tree的根结点和中间结点进行比较，只不过不是对K维数据进行整体的比较，而是选择某一个维度Di，然后比较两个K维数在该维度Di上的大小关系，即每次选择一个维度Di来对K维数据进行划分，相当于用一个垂直于该维度Di的超平面将K维数据空间一分为二，平面一边的所有K维数据在Di维度上的值小于平面另一边的所有K维数据对应维度上的值。也就是说，我们每选择一个维度进行如上的划分，就会将K维数据空间划分为两个部分，如果我们继续分别对这两个子K维空间进行如上的划分，又会得到新的子空间，对新的子空间又继续划分，重复以上过程直到每个子空间都不能再划分为止。以上就是构造Kd-Tree的过程，上述过程中涉及到两个重要的问题：1）每次对子空间的划分时，怎样确定在哪个维度上进行划分；2）在某个维度上进行划分时，怎样确保在这一维度上的划分得到的两个子集合的数量尽量相等，即左子树和右子树中的结点个数尽量相等。

**问题1： 每次对子空间的划分时，怎样确定在哪个维度上进行划分？**

最简单的方法就是轮着来，即如果这次选择了在第i维上进行数据划分，那下一次就在第j(j≠i)维上进行划分，例如：j = (i mod k) + 1。想象一下我们切豆腐时，先是竖着切一刀，切成两半后，再横着来一刀，就得到了很小的方块豆腐。

可是“轮着来”的方法是否可以很好地解决问题呢？再次想象一下，我们现在要切的是一根木条，按照“轮着来”的方法先是竖着切一刀，木条一分为二，干净利落，接下来就是再横着切一刀，这个时候就有点考验刀法了，如果木条的直径（横截面）较大，还可以下手，如果直径较小，就没法往下切了。因此，如果K维数据的分布像上面的豆腐一样，“轮着来”的切分方法是可以奏效，但是如果K维度上数据的分布像木条一样，“轮着来”就不好用了。因此，还需要想想其他的切法。

如果一个K维数据集合的分布像木条一样，那就是说明这K维数据在木条较长方向代表的维度上，这些数据的分布散得比较开，数学上来说，就是这些数据在该维度上的方差（invariance）比较大，换句话说，正因为这些数据在该维度上分散的比较开，我们就更容易在这个维度上将它们划分开，因此，这就引出了我们选择维度的另一种方法：==**最大方差法（max invarince），即每次我们选择维度进行划分时，都选择具有最大方差维度。**==

**问题2：在某个维度上进行划分时，怎样确保在这一维度上的划分得到的两个子集合的数量尽量相等，即左子树和右子树中的结点个数尽量相等？**

假设当前我们按照最大方差法选择了在维度i上进行K维数据集S的划分，此时我们需要在维度i上将K维数据集合S划分为两个子集合A和B，子集合A中的数据在维度i上的值都小于子集合B中。首先考虑最简单的划分法，即选择第一个数作为比较对象（即划分轴，pivot），S中剩余的其他所有K维数据都跟该pivot在维度i上进行比较，如果小于pivot则划A集合，大于则划入B集合。把A集合和B集合分别看做是左子树和右子树，那么我们在构造一个二叉树的时候，当然是希望它是一棵尽量平衡的树，即左右子树中的结点个数相差不大。而A集合和B集合中数据的个数显然跟pivot值有关，因为它们是跟pivot比较后才被划分到相应的集合中去的。好了，现在的问题就是确定pivot了。给定一个数组，怎样才能得到两个子数组，这两个数组包含的元素个数差不多且其中一个子数组中的元素值都小于另一个子数组呢？**方法很简单，找到数组中的中值（即中位数，median）**，然后将数组中所有元素与中值进行比较，就可以得到上述两个子数组。同样，在维度i上进行划分时，pivot就选择该维度i上所有数据的中值，这样得到的两个子集合数据个数就基本相同了。

解决了上面两个重要的问题后，就得到了Kd-Tree的构造算法了。

**Kd-Tree的构建算法：**

（1） 在K维数据集合中选择具有最大方差的维度k，然后在该维度上选择中值m为pivot对该数据集合进行划分，得到两个子集合；同时创建一个树结点node，用于存储；

（2）对两个子集合重复（1）步骤的过程，直至所有子集合都不能再划分为止；如果某个子集合不能再划分时，则将该子集合中的数据保存到叶子结点（leaf node）。

以上就是创建Kd-Tree的算法。下面给出一个简单例子。

给定二维数据集合：(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)，利用上述算法构建一棵Kd-tree。左图是Kd-tree对应二维数据集合的一个空间划分，右图是构建的一棵Kd-tree。

![image-20210924142413731](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142413731.png)

**Kd-Tree与一维二叉查找树之间的区别：**

二叉查找树：数据存放在树中的每个结点（根结点、中间结点、叶子结点）中；

Kd-Tree：数据只存放在叶子结点，而根结点和中间结点存放一些空间划分信息（例如划分维度、划分值）；

 

**构建好一棵Kd-Tree后，下面给出利用Kd-Tree进行最近邻查找的算法：**

（1）将查询数据Q从根结点开始，按照Q与各个结点的比较结果向下访问Kd-Tree，直至达到叶子结点。

其中Q与结点的比较指的是将Q对应于结点中的k维度上的值与m进行比较，若Q(k) < m，则访问左子树，否则访问右子树。达到叶子结点时，计算Q与叶子结点上保存的数据之间的距离，记录下最小距离对应的数据点，记为当前“最近邻点”Pcur和最小距离Dcur。

（2）进行回溯（Backtracking）操作，该操作是为了找到离Q更近的“最近邻点”。即判断未被访问过的分支里是否还有离Q更近的点，它们之间的距离小于Dcur。

如果Q与其父结点下的未被访问过的分支之间的距离小于Dcur，则认为该分支中存在离P更近的数据，进入该结点，进行（1）步骤一样的查找过程，如果找到更近的数据点，则更新为当前的“最近邻点”Pcur，并更新Dcur。

如果Q与其父结点下的未被访问过的分支之间的距离大于Dcur，则说明该分支内不存在与Q更近的点。

回溯的判断过程是从下往上进行的，直到回溯到根结点时已经不存在与P更近的分支为止。

 

**怎样判断未被访问过的树分支Branch里是否还有离Q更近的点？** 

从几何空间上来看，就是判断以Q为中心center和以Dcur为半径Radius的超球面（Hypersphere）与树分支Branch代表的超矩形（Hyperrectangle）之间是否相交。

在实现中，我们可以有两种方式来求Q与树分支Branch之间的距离。第一种是在构造树的过程中，就记录下每个子树中包含的所有数据在该子树对应的维度k上的边界参数[min, max]；第二种是在构造树的过程中，记录下每个子树所在的分割维度k和分割值m，（k, m），Q与子树的距离则为|Q(k) - m|。

 

以上就是Kd-tree的构造过程和基于Kd-Tree的最近邻查找过程。

下面用一个简单的例子来演示基于Kd-Tree的最近邻查找的过程。

数据点集合：(2,3), (4,7), (5,4), (9,6), (8,1), (7,2) 。

已建好的Kd-Tree：

![image-20210924142513943](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142513943.png)

查询点： (8, 3) （在左图中用茶色菱形点表示）

第一次查询：

![image-20210924142913148](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142913148.png)

当前最近邻点： (9, 6) ， 最近邻距离： sqrt(10)，

且在未被选择的树分支中存在于Q更近的点（如茶色圈圈内的两个红色点）

 

回溯：

![image-20210924142934628](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924142934628.png)



当前最近邻点： (8, 1)和(7, 2) ， 最近邻距离： sqrt(2) 

最后，查询点(8, 3)的近似最近邻点为(8, 1)和(7, 2) 。

**==另一种优化方法：==**

![image-20210924143957107](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924143957107.png)



**撒一次点，同时完成两颗树的构建，当$X_{new}$同时连接了两颗树时，路径构建成功。**

==**另一种在narrow passage环境的优化方式：**==因为在狭窄通道内采样点很少，所以对于终点是在narrow passage中的情况，可以在narrow passage中生成一棵树。

![image-20210924144437003](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924144437003.png)



## 3.3 基于采样的最优路径规划算法

Optimal sampling-based path planning methods

为了解决RRT生成路径不是最优的问题，故有了RRT*算法。

![image-20210924145415041](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924145415041.png)



不同于RRT，RRT*算法找到$X_{new}$之后是没有直接扩展到树中的。而是通过NearC函数找到$X_{new}$附近的一些邻域节点（以一定的半径来找），然后通过线段和$X_{near}$连接起来。

然后找$X_{new}$的父节点，计算准则：从起始点到$X_{new}$，可以通过$X_{near}$到，也可以通过$x_1$或$x_2$到。代价函数就是路径最短。

所以这个时候$X_{near}$就被选择为父节点。然后把这父节点、$X_{new}$点和边扩展到树中。

![image-20210924151016473](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924151016473.png)

**==rewire()函数：剪枝过程（局部重连接）。==**

如下图所示：蓝色的线段如果比红色的线段短，那么$x_2$就修改父节点，原来的父节点是$x_1$，现在修改为$X_{new}$。

**剪枝过程不断进行，从而使树不断优化，从而使找到的目标路径越来越短。**

所以RRT*算法,找到目标路径之后，不会立刻停止，会持续不断地优化。

![image-20210924152115575](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152115575.png)

![image-20210924152405181](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152405181.png)

==**Kinodynamic-RRT*:直线路径对于很多机器人是没法完成的（比如车需要往前走，才能完成水平方向的位移）**==

用曲线代替直线，使之更符合机器人的运动。

![image-20210924152857462](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924152857462.png)

用曲线代替直线，可能会出现一些有意思的问题：比如有些原本会出现碰撞的线段，变成曲线后不会碰撞。

![image-20210924153244908](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924153244908.png)

目前关于Kinodynamic RRT*算法的研究有很多，比较火，集中在无人机、机器人的路径规划方面，考虑机器人的约束，就会有很多的问题。

**Anytime-RRT***

找到一条路径了，如何去追踪这条路径。在Anytime-RRT*的路径规划中，即使从树中找到了一条目标路径，但是这条路径仍是在动态更新的。在构建树的过程中，起始点就动态地变成了机器人的实时位置。相对于固定死的路径规划（先规划好路径再让机器人去执行）来讲，**Anytime-RRT***能更好地去适应环境变换比较大的情况。

![image-20210924155528668](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924155528668.png)

总结：![image-20210924155632632](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924155632632.png)

## 3.4 先进的采样方法

==**Informed RRT***：==

在空间里面均匀地撒点，其实很多过程是浪费的，所以把采样的过程限制在一个椭圆里面，这个**椭圆**是围绕已生成的路径产生的，从而对路径本身做优化。

![image-20210924160847204](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924160847204.png)

当路径生成之后，如何构建椭圆？

以起始点和终点作为椭圆的焦点，生成路径的长度就是代表椭圆的常数。因为随着优化的进行，路径变短了，常数越小，椭圆会变得越来越扁，所以采样的范围也会变得越来越小。从而优化的效率得到提高。

这里的优化主要是指路径最短。

![image-20210924161027414](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924161027414.png)



**==Cross-entropy motion planning==**

首先是先生成一条路径（最左边红色路径），在轨迹的六个节点的周围椭圆区域进行采样，就能得到很多条路径，这6个节点构成了多高斯模型。例如：第三幅图中，通过两次采样，得到了新的两条路径。一共有三条路径。

![image-20210924190459084](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924190459084.png)

生成了多条轨迹之后，我们对多个轨迹的多个节点，求一个均值。这个均值作为新的多高斯分布，下次采样过程就在新的高斯分布中进行采样。

![image-20210924191514953](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924191514953.png)

如下图，从左到右，展示了根据采样的不断优化，生成路径逐渐变得光滑的过程。

![image-20210924191907096](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924191907096.png)

不管是Cross-entroy还是Informed RRT*都是对采样的过程进行优化。

只要不跳出基于采样的框架，那么要改进的东西就在Sample()、Near()、Steer()函数中。

## 3.5 算法实践

Ompl库，集成了很多运动规划算法，但是场景更偏向于机械臂。

Navigation stick ，专门设计为移动机器人用的库。

![image-20210924193124281](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210924193124281.png)

在ROS中实现RRT*程序时，需要对OMPL库有一定的了解。程序中都用到了这些基础类。

![image-20210926164143601](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926164143601.png)

# 4.动力学约束下的路径规划

在前几课中，是不考虑机器人的运动学模型的。考虑了机器人的运动学模型之后，也可以分为基于搜索的和基于采样的。

![image-20210926165157682](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926165157682.png)

## 4.1 总体介绍

Kinodynamic:合成词，是由运动学+动力学组成的。

定义：是一种生成机器人的运动，同时受限于运动学的约束：避障，和动力学的约束：比如说在速度、加速度和机器人产生的力的上下限的约束。

特点：受到高阶模型的约束(微分)，加速度约束。

![image-20210926165250172](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926165250172.png)

问题：既然有后端优化，为什么在前端动力学搜索的时候，还需要考虑机器人的高阶动力学约束呢？

答：如果在前端考虑，后端的压力就会减轻。不能在前端粗暴的找路径，不考虑任何的动力学。

![image-20210926170151893](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926170151893.png)



轨迹优化是局部的，换句话说，你很难把一个轨迹，在从障碍物的左侧，给它优化到另一侧。例如：下图中无人机有朝右侧的初速度，最好的轨迹应该是右侧绿色虚线（优化后），而如果只考虑质点模型，就可能产生紫色实线的路径，轨迹优化后产生在障碍物左侧的紫色虚线路径。

考虑动力学和不考虑动力学，产生的轨迹拓扑是有很大区别的。

![image-20210926170719794](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926170719794.png)

## 4.2 状态栅格规划器State Lattice Planning

两种方法：

1.前向方法：把机器人的控制空间进行离散，驱动机器人往前运动。

2.逆向方法：离散机器人的状态空间。

![image-20210926182516097](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926182516097.png)

如下图，在栅格地图中，让机器人进行4连接或8连接的运动，实际上是对控制空间的离散。

![image-20210926182800938](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926182800938.png)

采样实质是对状态空间的离散。

![image-20210926183228193](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926183228193.png)

1.离散控制空间：给定初始状态，选择控制输入，给定一段时间，前向模拟。

2.离散状态空间：如下图，在状态空间中，我采样到了t1时刻的状态，(x,y)。逆向计算出我在t0时刻应该怎样踩油门打方向盘持续多久，才能得到这样一条轨迹。

这样天然地具有启发性，具有贪心的性质，我想让车开到哪里，可以很明确的知道。

![image-20210926190707491](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926190707491.png)

无人机：双积分模型，在控制空间中采样。系统在不同的输入激励下，保持一定的时间，演化出不同的状态。

Jerk：加速度的导数，如果拿jerk作为控制输入的话，那么加速度也要放在状态空间里了。那么是三阶积分系统

紫色的曲线，就代表了状态转移过程。

![image-20210926193239428](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926193239428.png)

A矩阵的特殊性质：nilpotent幂零矩阵，有很好的特性，可以让计算变快，缩短planning的时间。我们非常看重它。

$A^i=0$当i超过几次之后，就变成0了

**我们怎样还原出过程的轨迹呢?这就涉及到状态转移方程。**

无人机系统，前向积分的函数表达式。$S(t)$随着时间变化的函数，$F(t)$零输入响应，$G(t)$零状态响应。$u_m$控制输入。

给定一个具体的时刻t1，具体的$S(t1)$怎样计算，就很头疼，

$e^{At}$:状态转移矩阵,关于它的计算，一般会将它做展开（无穷级数），如果A是幂零矩阵，那么后面的项就可以舍弃。极大地简化计算。

![image-20210926194406984](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926194406984.png)

左图：每个边做9次离散化，右图：每个边做25次离散化。这样的图称做Lattice Graph

![image-20210926195453048](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926195453048.png)

与无人机的思路一样，先从搜索树中挑选一个模型，选择控制输入，给定一定的时间，得到一条轨迹，如果无碰撞就添加到结果中。

![image-20210926202344260](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926202344260.png)

说完了控制空间中的离散化，然后是状态空间的离散化。

给定一个状态，反算它们中间的连接方式，就可以算出来很多边的连接。



**比较**：在控制空间里采样是很没有目的性的。很多离散控制量产生的feasible motion connections,会开到路外面去，是不可用的。

但如果是在状态空间里采样，是可以保证落在马路上的，因为是根据结果反算的。效率也高。

但是状态空间采样非常难实现。**给定了初始状态和末尾状态，到底怎么把中间路径给算出来**，这就涉及到解边界值问题：

**==Boundary Value Problem(BVP)==**

![image-20210926203123871](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210926203123871.png)

以无人机为例，求解边界值问题：

![image-20210927090309268](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927090309268.png)

对$x(t)$做参数化，五阶多项式，假设在边界时刻，速度、加速度都是0。然后要解出$x(t)$的参数${c_5,c_4,...,c_0}$

对于$x(t)$的两个边界条件，代进去；然后一阶导：速度，两个状态，代进去；二阶导：加速度，两个状态，代进去。

得到6个方程。最后解方程组。

**获得一个BVP问题的解不是很困难，但是获得一个最优的BVP解是很困难的。**

![image-20210927090331152](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927090331152.png)



**目标：对于无人机系统，我希望jerk的平方项在一定时间长度上的积分是最小的。**

**$J_k$中的k代表某个轴，这里将无人机planning的x,y,z轴分开独立进行，简化问题。**

系统的状态：${p,v,a}$，输入:$j=u$

系统模型：积分模型，由系统状态求导而来。

解决方法：利用极小值原理去求解最优控制的问题。

![image-20210927091536563](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927091536563.png)

庞特李亚金的极小值原理：庞特里亚金极小值原理是在控制向量u(t)受限制的情况下，使得目标函数J取极小，从而求解最优控制问题的原理和方法，又称极大值原理。λ是协态向量，系统模型有多少个变量就有多少个协态。s和u都是省略了符号t的，代表某一时刻的最优状态和最优控制，是一个常数。利用庞特里亚金极小值原理**求解最优控制问题首先需要求解协态方程，也就是λ，然后再求解最优控制u*，求解完u*之后，即可得到最优状态。**

目标函数J由两部分组成，第一是末状态的惩罚项$h(s(T))$,就是说希望T时刻无人机的状态逼近期望；第二项：是整个T时刻，机器人运动的能量损耗。

最后要求解的是最优状态$S^*(t)$和最优输入$u^*(t)$。

这个协变量λ是微分方程：哈顿函数的解,在其中的状态$S^*(t)$和控制输入$u^*(t)$都取到了最优解的时候，对里面的S求一个偏导数，再取负号。



![image-20210927092734613](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927092734613.png)

3. 求解最优控制
根据庞特里亚金极小值原理中的：![image-20210927112430049](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927112430049.png)

最优的u*的选取是，当哈密顿函数中的s取最优时，能够使得哈密顿函数最小的那个u即为最优控制量。令导数等于0即可。
**求解出最优输入和最优状态轨迹：**最优输入求出来之后，状态就是输入做积分。分别积分一次、二次、三次得到。

那么最后只差$\alpha,\beta,\gamma$三个常数值没确定。

![image-20210927100445468](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927100445468.png)

**这三个常数用最后末尾时刻的边界条件来确定**。把末尾时刻T代进去，$s^*(T)=s_f$。

可以算出，$\alpha,\beta,\gamma$三个参数只跟T相关，进一步可以得出，代价J也只跟T相关。

所以，在状态空间内的采样问题，**只要给定初始状态、末尾状态、时刻T，那么所有的东西全都可以计算出来了。**

J只依赖于T，所以变成了一个单变量多项式求极值的问题。即$f'(T)=0$的问题。就变成了多项式求根的问题，所以就变得很快了，可以用很小的代价就把最优的T求出来。

![image-20210927101128034](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927101128034.png)



对于末状态部分指定的问题，即（p,v,a）只要p达到，va可以自由指定的问题。那么λ(t)的边界条件是存在的,对于不是给定的状态分量。

![image-20210927102456229](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927102456229.png)

贪心的设计原则：

![image-20210927105550812](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927105550812.png)

## 4.3 Hybrid A*

一种具体地机器人实时地Kinodynamic路径规划算法（基于搜索的方法）。prune:剪枝

**工作流程：**

lattice图：离散输入时，比如分成20份，会导致图非常稠密，当一条边遇到障碍物时，会导致它邻近的边也一起遇到障碍物了。那就自然想到能不能对图做一个剪枝。

随着向前积分，从一个网格出现到另一个网格（红点），如果有多个状态线都到了同一个网格，选取cost最小的那一根进行更新。永远只保持一个网格里只有一个节点。

![image-20210927112635013](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927112635013.png)

找邻居的不同：Hybrid A$*$是找周围的邻近状态，而A*是找周围邻近的八个点，而JPS是打破对称性，跳点寻找。

![image-20210927145305307](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927145305307.png)

如何合理的设计启发式函数？

non-holonomic 非完整约束。

holonomic:完整约束。

![image-20210927150659964](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927150659964.png)

其他技巧：随着树离终点越来越近，是不是可以通过一次one shot尝试，直接解算出到终点的路径（解一个最优控制问题）

![image-20210927151909238](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927151909238.png)

Fast-planner用的就是Hybrid A*算法。

![image-20210927153341046](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927153341046.png)

## 4.4 Kinodynamic RRT*

第一个不同：选择父节点时的区别：当Kiondynamic RRT*找到了自己的父节点之后，连接两点之间的状态线不再是直线，这就是求解一个最优两点边界值OBVP问题，

![image-20210927155240191](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927155240191.png)

第一步：怎样采样“Sample”，不能像RRT一样，只在位置空间（x,y,z）采样了，要求在全状态空间采样，例如二阶系统就是（p,v）

![image-20210927155810303](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927155810303.png)

第二步：用最优控制的知识，把新采样的state和最邻近的state，做一个连接。（比如根据前面的极小值原理。）

![image-20210927160058060](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160058060.png)

那么如何做一个最优控制的连接呢？（另一种方法）：两种状态是near的当它们状态转移时cost最小。

![image-20210927160452296](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160452296.png)

第三步：怎样选择父节点。在高维的状态空间里，找一个state，使得

![image-20210927160834666](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927160834666.png)

前向可达集，后向可达集

![image-20210927162005387](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927162005387.png)

![image-20210927162131269](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927162131269.png)

## 4.5 算法实践Local Lattice planner

Local State Lattice Planner作业：

包括求解最优边界问题（BVP），找出最小代价。

节点图：

![image-20210927200227729](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927200227729.png)

结果图：

![image-20210927200246767](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210927200246767.png)

# 5.Minimum Snap Trajectory Generation轨迹生成

## 5.1 总体介绍

为什么需要一条光滑轨迹呢？

1.首先适合机器人运动

2.速度或更高阶的动力学量不能突变。

3.机器人不应该突然刹车或转弯

4.节能

![image-20210923163559813](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923163559813.png)

问题：已经有了前端，为什么还需要后端？

答：后端为了做优化，得到一条轨迹，适合机器人执行。

问题：前端已经是动力学可行的了，为什么还需要轨迹优化呢？

比如：下图红色曲线，是Hybrid A*生成的，而蓝色曲线是优化后的，很明显更加光滑。这就是轨迹优化的作用。

整个框架一定是满足一个coarse->fine 从粗到精的过程，

![image-20210928143047976](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928143047976.png)

边界条件：要满足当前机器人运动的起始状态，也可以指定运动的末状态

中间条件：waypoint 一般指中间节点，这些中间点可以是你前端路径搜索出来的。也可以是人为指定的，比如巡检任务。

轨迹是否光滑的评价准则：需要一个评价函数，来评价轨迹是否光滑，经过路标点的时候，轨迹在这个点的左极限和右极限是连续的。

对于多路标点的轨迹生成的问题：往往会把它变成分段轨迹求解的问题。

![image-20210928144943185](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928144943185.png)



## 5.2 Minimum snap Optimization

微分平坦：一个移动机器人系统，可以把它在全维度的状态空间的planning问题，转变成在低维的，进行挑选过后的，平坦的flat output输出空间里来进行轨迹规划。它的要求是**==我们整个的状态空间，都可以被平坦空间里的变量以及各阶导数，进行代数表示。==**

在无人机系统中，在很多年前的控制工作里，已经证明了，可以通过精心设计一个在SE(3)上的几何跟踪控制器，可以使得所有在flat output空间里生成的轨迹，如果这些轨迹的各个状态及它们的导数是合理的bounded住，(合理:指的是不会快速发散)，这样生成的轨迹一定是可以被跟踪的。

![image-20210928150744180](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928150744180.png)

对于无人机12维的状态空间来说，四变量的空间。

**牛顿方程：表达平移量的运动。**

左边：world系下的合外力，ma；右边：重力+四轴的合外力。飞机的推力合力方向一定是垂直于桨平面的，所以在机体系下的合力为u1。

**欧拉方程：表达转动量的运动。**

u2、u3、u4是力矩。

![image-20210928151916588](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928151916588.png)

**证明：确实可以把无人机12维的状态空间，压缩到4维平坦空间${x,y,z,\psi}$。**

即所有其他变量可以被这四个变量以及它们的导数代数组合。

无人机的加速度和它的姿态是绑定的，所以规划它的加速度和规划它的姿态，两者只能取其一。因为姿态存在比较强的非线性，所以一般来说，还是选取加速度去做planning。

对于无人机来说，是没有机头这个概念的。**相对来说，偏航角是独立的，因为不管是任何偏航角，推力是不受影响的。**

首先先位置与线速度，线速度是位置的导数，所以本身就在平坦空间里了，故线速度不用再证明。

![image-20210928154425190](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928154425190.png)

接下来，就要花力气看无人机的姿态。无人机的姿态靠三轴的方向来描述（因为欧拉角是通过绕三轴旋转得到的）

t就是三轴合加速度（$\delta_1,\delta_2,\delta_3$就是x,y,z），所以Body系的，Z轴的方向$Z_B$已经得到。

$X_C$是为了方便引入了中间坐标系，它和$X_w$只差了一个偏航角$\psi$。所以就可以用$\psi$(即$\delta_4$)表示出$X_c$

$Y_B$显然可以由$Z_B\times X_c$得到

![image-20210928172103264](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928172103264.png)

那么姿态搞定之后，现在只剩下角速度了。

我们还是从四旋翼无人机的运动公式着手，后一项$w_{BW}$涉及到对旋转的坐标系$Z_B$求导。

推力的导数：等于无人机整个合力的导数，$Z_B$表示方向。

把$\dot{u_1}$代入运动方程，可以得到$h_w$,是一个暂时自己定义出的物理量，先不管它的具体含义。这个量现在就是被flat output代数表示出来的。

![image-20210928175824247](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210928175824247.png)

那么继续推导，现在已经有了$h_w$这样一个中间量，那么又有$w_{BW}$的表达式，显然$X_B \times Z_B = - y_B$，将$w_{BW}$代入$h_w$中，就可以得到$w_x,w_y$了。

![image-20210929101006248](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929101006248.png)

那么现在只剩下$w_z$这个漏网之鱼。

![image-20210929101545220](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929101545220.png)

那么现在已经全部搞定了。那么接下来你只需要记住：接下来我们对无人机的运动规划一定是在${x,y,z,\psi}$以及它们的导数上进行。

![image-20210929091326626](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929091326626.png)

那么我们最后给无人机生成的轨迹指令呢，==**我们实际上就是规划出，${x,y,z}$以及一阶二阶导数和${\psi}$,**==控制的时候呢，位置控制器会计算出期望的姿态，然后交给姿态控制器，位置控制器解算出推力$u_1$，姿态控制器解算出三个方向力矩$u_2,u_3,u_4$，然后最后真实的去控制无人机。

![image-20210923170157388](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923170157388.png)

接下来看轨迹的表示形式，和我们在OBVP问题中一样，算出来的**==轨迹实际上就是一个多项式==**。

多项式函数非常容易定义光滑准则。多项式函数易于计算各阶导数。多项式函数非常简单在三个轴上进行解耦。

![image-20210929103637990](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929103637990.png)

首先对于一维的一段轨迹来说，多项式提供了一个轨迹光滑的保证，因为多项式是多阶可导的。

光滑是表示可导，比如说我们想要轨迹的速度是光滑的，那么前提是速度的导数加速度，至少要是连续的。

多项式提供了这样一个便利，可以在它的阶数内进行多次求导，天然地就是光滑的。

![image-20210923164005036](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164005036.png)

这里的缺点是，缺少中间条件。对于移动机器人来说，它的中间轨迹点，速度、加速度肯定不是0，所以至少要给定一个指定的值。

![image-20210923164110116](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164110116.png)

期望有一个定值v

![image-20210929105401697](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929105401697.png)

这里就涉及到一个问题：为什么速度、加速度是人为指定的？如果是人为指定的，应该指定成多少才是合理的？

对于一个复杂的问题来说，其实完全无法预测移动机器人以什么样的速度、加速度到这个点才是最好的。所以往往是不能指定v和a的。

这就是我们要用优化的方式来做的了，**==用优化的方法来算一个最佳的到达这些位置的v和a。==**

![image-20210923164418608](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923164418608.png)

接下来用无人机举例，**==怎么用Minimum Snap来求解v和a==**。

![image-20210923163859801](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923163859801.png)

我们反复强调了无人机的加速度和姿态（旋转）是绑定的。角速度和推力是对应的。

![image-20210929110302949](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929110302949.png)

由这个我们就可以得到一个指标：如果最小化无人机的jerk，相当于最小化了角速度。

那么最小化角速度有什么好处呢？大家都知道，无人机常用视觉导航，举个例子，如果让摄像头原地旋转，那么视差是变化的非常快的，跟只有平移量是不一样的，此时VIO是很容易挂掉的，==**那么最小化角速度，其实就是最小化视差的变化率，一般认为对视觉的跟踪是有好处的。**==

那么最小化Snap呢？因为snap是对应推力的导数，一般认为**==它使得推力的变换尽可能的平缓，所以节省能量==**。

![image-20210929110410976](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929110410976.png)

那么现在目标已经明确了，就是要计算分段多项式（是轨迹多项式的导数）的系数，使得总体的轨迹是光滑的。使得分段多项式满足边界条件，经过中间点，中间点的轨迹前后段的左右极限是高阶导数都是一样的。

![image-20210929111347159](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929111347159.png)

轨迹分段多项式的形式如下：

1.每一段轨迹都是多项式

2.不一定要强调每一段轨迹的多项式阶次是一样的，但如果是一样的会使得问题更简单。

3.每一段轨迹的时间一定要是已知的。

![image-20210929111746008](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929111746008.png)

满足边界条件约束和连续条件约束。

![image-20210929112232532](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929112232532.png)

怎么合理地选择轨迹的阶数呢？

确保k阶是光滑的，k+1阶是连续的。最小化控制输入的几阶导数

![image-20210929112318880](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210929112318880.png)

一般会有一些工程上的约定：



## 5.3 Closed-form Solution to Minimum Snap

## 5.4 Implementation Details

## 5.5 Homework

从路径规划->轨迹规划



![image-20210923181338817](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923181338817.png)

**==snap就是加速度的两阶导数。==**

![image-20210923181821132](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923181821132.png)

![image-20210923182558336](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20210923182558336.png)

# 6.软约束和硬约束下的轨迹优化

# 7.基于马尔科夫决策过程的运动规划

# 8.模型预测控制在运动规划的应用

# 9.实践Project